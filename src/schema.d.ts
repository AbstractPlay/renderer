/* tslint:disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * Pattern for the global stash definitions for the `homeworlds` renderer.
 */
export type Stashstrings = string;

/**
 * Games on the Abstract Play service must produce representations of the play area based on this schema. The front-end renderer will then translate that into various forms. Detailed documentation is difficult within a JSON document (e.g., no multi-line strings allowed), so see the website for standalone documentation.
 */
export interface APRenderRep {
  /**
   * The rendering engine the game wants to use.
   */
  renderer?: "default" | "stacking" | "homeworlds";
  /**
   * Map each `piece` to an actual glyph with possible options.
   */
  legend?: {
    [k: string]:
      | string
      | {
          /**
           * The name of the actual glyph.
           */
          name: string;
          /**
           * A positive integer pointing to a player position. Based on user settings, an appropriate background fill colour will be chosen.
           */
          colour?: number;
          [k: string]: any;
        };
  };
  /**
   * This is the game board itself.
   */
  board:
    | {
        style:
          | "squares"
          | "squares-checkered"
          | "vertex"
          | "go"
          | "hex_odd-r"
          | "hex_even-r"
          | "hex_odd-c"
          | "hex_even-c"
          | "hex_of_hex"
          | "hex_of_tri"
          | "snubsquare" | string;
        /**
         * Only meaningful for the 'hex_of_*' styles. Determines the minimum width at the top and bottom of the board.
         */
        minWidth?: number;
        /**
         * Only meaningful for the 'hex_as_*' styles. Determines the maximum width at the centre of the board.
         */
        maxWidth?: number;
        /**
         * Optional. If not provided, the renderer will calculate based on the `pieces` property. If only one of 'width' and 'height' is specifed, the board is assumed to be square.
         */
        width?: number;
        /**
         * Optional. If not provided, the renderer will calculate based on the `pieces` property. If only one of 'width' and 'height' is specifed, the board is assumed to be square.
         */
        height?: number;
        /**
         * Only meaningful for the `squares` and `vertex` boards. Places heavier grid lines to create tiles that are X grids by X grids square.
         */
        tiling?: number;
      }
    | {
        /**
         * The name of the system. For simplicity, no whitespace, no weird characters, and 1â€“25 characters in length.
         */
        name: string;
        /**
         * If this is a home system, give the compass direction representing the player's seat. Omit property in shared systems.
         */
        seat?: "N" | "E" | "S" | "W";
        /**
         * Describes the system's stars.
         */
        stars: string[];
      }[];
  pieces: null | string | string[][][] | string[][];
  /**
   * Areas are placed vertically under the game board. There's no default way of handling this. Each renderer will need to know what to do with it.
   */
  areas?: {
    R: Stashstrings;
    G: Stashstrings;
    B: Stashstrings;
    Y: Stashstrings;
    [k: string]: any;
  }[];
  /**
   * Player-specific data that the front end can use to render a helpful sidebar (identifying the pieces a player controls, running score, etc.).
   */
  metadata?: {
    /**
     * If a simple boolean, the system will derive the player's colour based on user settings. If a string, it will try to match that string against the `legend` and render that specific glyph.
     */
    pieces?: boolean | string;
    /**
     * Represent a numeric score.
     */
    score?: number;
    [k: string]: any;
  }[];
  [k: string]: any;
}
