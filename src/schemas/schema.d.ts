/* eslint-disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * Pattern for hex colour strings
 */
export type Colourstrings = string;
/**
 * Colours can also be derived using various functions.
 */
export type Colourfuncs = FunctionFlatten | FunctionLighten;
export type PositiveInteger = number;
/**
 * Schema for the `matrix` part of a polyomino-related feature
 */
export type Polymatrix = (PositiveInteger | Colourstrings | Colourfuncs | 0 | null)[][];
/**
 * The types of pieces supported in an isometric legend.
 */
export type IsometricPieces =
  | "cube"
  | "cylinder"
  | "hexp"
  | "hexf"
  | "lintelN"
  | "lintelE"
  | "lintelS"
  | "lintelW"
  | "lintelNS"
  | "lintelEW"
  | "spaceCube";
export type BoardStyles =
  | "squares"
  | "squares-checkered"
  | "squares-beveled"
  | "squares-stacked"
  | "squares-diamonds"
  | "vertex"
  | "vertex-cross"
  | "vertex-fanorona"
  | "pegboard"
  | "hex-slanted"
  | "hex-odd-p"
  | "hex-even-p"
  | "hex-odd-f"
  | "hex-even-f"
  | "hex-of-hex"
  | "hex-of-tri"
  | "hex-of-cir"
  | "snubsquare"
  | "snubsquare-cells"
  | "onyx"
  | "circular-wheel"
  | "circular-cobweb"
  | "circular-moon"
  | "sowing"
  | "conhex-dots"
  | "conhex-cells"
  | "cairo-collinear"
  | "cairo-catalan"
  | "triangles-stacked"
  | "conical-hex"
  | "conical-hex-narrow"
  | "pyramid-hex"
  | "heightmap-squares"
  | "dvgc"
  | "dvgc-checkered";
/**
 * The patterns known by the renderer
 */
export type PatternName =
  | "microbial"
  | "chevrons"
  | "honeycomb"
  | "triangles"
  | "wavy"
  | "slant"
  | "dots"
  | "starsWhite"
  | "cross"
  | "houndstooth";
/**
 * The required schema for the `homeworlds` renderer. It supports 4 players and colours. The `board` property describes the systems. The `pieces` property describes the pieces.
 */
export type BoardHomeworlds = {
  /**
   * The name of the system. For simplicity, no whitespace, no weird characters, and 1â€“25 characters in length.
   */
  name: string;
  /**
   * If this is a home system, give the compass direction representing the player's seat. Omit property in shared systems.
   */
  seat?: "N" | "E" | "S" | "W";
  /**
   * Describes the system's stars. (For reasons, the schema does not require 1 or 2 stars, but in practice anything other this will give undefined results.)
   */
  stars: string[];
}[];
/**
 * The required schema for the `homeworlds` renderer. It supports 4 players and colours. The `board` property describes the systems. This property describes the pieces in each system. The order the systems are declared must be the same as how they are declared in the `board` property. That means the arrays must also be the same length. Empty arrays are allowed because sometimes you need to display an empty home system in the middle of a turn.
 */
export type PiecesHomeworlds = string[][];
/**
 * Pattern for the global stash definitions for the `homeworlds` renderer.
 */
export type Stashstrings = string;
/**
 * Annotations specifically for the `freespace` renderer.
 */
export type AnnotationFreespace =
  | {
      type: "path";
      path: string;
      fill?: PositiveInteger | Colourfuncs | Colourstrings;
      fillOpacity?: number;
      stroke?: PositiveInteger | Colourfuncs | Colourstrings;
      strokeWidth?: number;
      strokeOpacity?: number;
      /**
       * A valid `dasharray` appropriate for the game's display.
       */
      dashed?: number[];
    }
  | {
      /**
       * A way of incorporating a glyph from the legend into the board itself. This one is specific to the `freespace` renderer.
       */
      type: "glyph";
      /**
       * The name of the glyph in the `legend`.
       */
      glyph: string;
      /**
       * Provide absolute x,y coordinates.
       *
       * @minItems 1
       */
      points: [
        {
          x: number;
          y: number;
        },
        ...{
          x: number;
          y: number;
        }[]
      ];
    };

/**
 * Games on the Abstract Play service must produce representations of the play area based on this schema. The front-end renderer will then translate that into various forms. Detailed documentation is difficult within a JSON document (e.g., no multi-line strings allowed), so see the website for standalone documentation.
 */
export interface APRenderRep {
  /**
   * The rendering engine the game wants to use.
   */
  renderer?:
    | "default"
    | "stacking-offset"
    | "stacking-tiles"
    | "stacking-expanding"
    | "stacking-3D"
    | "homeworlds"
    | "homeworlds-orig"
    | "entropy"
    | "freespace"
    | "sowing-numerals"
    | "sowing-pips"
    | "conhex"
    | "multicell-square"
    | "polyomino"
    | "isometric";
  /**
   * A list of flags to pass to the renderer. The `hide-labels` option hides all external row/column labels. The `hide-labels-half` option only applies to boards with double labelling (e.g., square boards), and it hides the labels on the top and right of the board. `no-border` hides the very outside border of the square boards. The `hw-*` options are for Homeworlds. The option `clickable-edges` only applies to rect-of-hex and `squares*` boards and makes the individual edges clickable. The option `reverse-letters` reverses the order of the column or row displaying letters. The option `reverse-numbers` does the same for numerical labelling. The option `swap-labels` swaps the position of the letters and numbers. The option `no-piece-click` disables all click handling of pieces; instead only the board cells themselves detect the clicks.
   */
  options?: (
    | "hide-labels"
    | "hide-labels-half"
    | "hide-star-points"
    | "no-border"
    | "hw-light"
    | "hw-no-buttons"
    | "hw-system-only"
    | "clickable-edges"
    | "reverse-letters"
    | "reverse-numbers"
    | "swap-labels"
    | "no-piece-click"
  )[];
  /**
   * Map each `piece` to an actual glyph with possible options.
   */
  legend?: {
    [k: string]: string | Glyph | [Glyph, ...Glyph[]] | Polymatrix | IsoPiece;
  };
  /**
   * This is the game board itself.
   */
  board: null | BoardBasic | BoardHomeworlds | BoardEntropy | BoardFreespace;
  /**
   * Describes what pieces are where. For the `entropy` renderer, the pieces should be laid out on a grid 14 cells wide, which the renderer will break up into the two different boards. For cobweb boards, the center space is the final row, by itself. And for the `sowing` boards, the end pits (if present) should also appear on a row by themselves, west first (left), then east (right).
   */
  pieces: null | string | [string[][], ...string[][][]] | PiecesHomeworlds | Freepiece[] | Multipiece[] | Polypiece[];
  /**
   * Areas are renderer-specific elements that are used and rendered in various ways.
   */
  areas?: (
    | AreaPieces
    | AreaReserves
    | AreaPolyomino
    | AreaHWStash
    | AreaStackingExpanded
    | AreaVolcanoStash
    | AreaButtonBar
    | AreaScrollBar
    | AreaCompassRose
    | AreaKey
  )[];
  /**
   * Instruct the renderer how to show any changes to the game state. See the docs for details. For the `entropy` renderer, the pieces are theoretically laid out on a grid 14 cells wide. So to show annotations on the second board, you will reference column indexes starting at 7. The number of rows does not change.
   */
  annotations?: (AnnotationBasic | AnnotationSowing | AnnotationHomeworlds | AnnotationFreespace)[];
}
/**
 * An individual glyph with options, used in the `legend` property.
 */
export interface Glyph {
  /**
   * The name of the actual glyph. It may not contain any whitespace.
   */
  name?: string;
  /**
   * Mutually exclusive with `name`. In this case, the glyph is plain text, shrunk down to the appropriate size to fit in a cell. This is intended for very short strings, like numbers.
   */
  text?: string;
  /**
   * A 3- or 6-digit hex colour value, a player position, or a gradient.
   */
  colour?: Colourstrings | Colourfuncs | PositiveInteger | Gradient;
  /**
   * A 3- or 6-digit hex colour value, a player position, or a gradient.
   */
  colour2?: Colourstrings | Colourfuncs | PositiveInteger | Gradient;
  /**
   * A number representing how you want the glyph proportionately scaled. Numbers <1 will shrink the glyph. Numbers >1 will enlarge it.
   */
  scale?: number;
  /**
   * A number between 0 and 1 indicating how opaque to render the glyph. A value of 0 means completely transparent.
   */
  opacity?: number;
  /**
   * A number between -360 and 360 representing the degrees to rotate the glyph. Negative values rotate counterclockwise.
   */
  rotate?: number | null;
  /**
   * Determines how the piece (usually a text element) is reorientated after rotation is done. 'vertical' means it will always be reorientated vertically. Otherwise, it rotates along with everything else.
   */
  orientation?: "vertical" | "fluid";
  /**
   * The number of units to nudge the glyph from centre.
   */
  nudge?: {
    /**
     * Negative values move the glyph to the left.
     */
    dx?: number;
    /**
     * Negative values move the glyph up.
     */
    dy?: number;
  };
}
/**
 * This function returns the fully opaque colour that is equivalent to overlying the foreground colour with the given opacity over the background colour.
 */
export interface FunctionFlatten {
  func: "flatten";
  fg: PositiveInteger | Colourstrings;
  bg: PositiveInteger | Colourstrings;
  opacity: number;
}
/**
 * Lightens or darkens a colour by the specified amount of saturation and luminance. Positive deltas lighten, negative darken.
 */
export interface FunctionLighten {
  func: "lighten";
  colour: PositiveInteger | Colourstrings;
  ds: number;
  dl: number;
}
/**
 * A gradient one can use for flood fills and the like.
 */
export interface Gradient {
  x1?: number;
  y1?: number;
  x2?: number;
  y2?: number;
  /**
   * @minItems 2
   */
  stops: [GradientStop, GradientStop, ...GradientStop[]];
}
/**
 * Schema for a gradient stop
 */
export interface GradientStop {
  /**
   * Interpreted as a percent, like opacity
   */
  offset: number;
  /**
   * Hex string or player number of the desired colour
   */
  colour: PositiveInteger | Colourstrings | Colourfuncs;
  opacity?: number;
}
/**
 * Schema for a single piece in an `isoPieces` object.
 */
export interface IsoPiece {
  piece: IsometricPieces;
  height: number;
  colour: Colourstrings | Colourfuncs | PositiveInteger;
  /**
   * As a percentage of the cell size. By default, pieces are shrunk by 25% within the cell.
   */
  scale?: number;
}
/**
 * One of the preset boards.
 */
export interface BoardBasic {
  style: BoardStyles;
  /**
   * Allows the game itself to rotate the base board. This is added to whatever user-provided rotation is requested. Rotation is applied after the entire board is rendered, and then key elements are reoriented vertically.
   */
  rotate?: number;
  /**
   * The colour for the board labels. Defaults to the colour passed into the context (default black).
   */
  labelColour?: Colourfuncs | Colourstrings;
  /**
   * The colour for lines drawn to construct the board.
   */
  strokeColour?: Colourfuncs | Colourstrings;
  /**
   * The base stroke weight of lines drawn to construct the board.
   */
  strokeWeight?: number;
  /**
   * The opacity of lines drawn to construct the board.
   */
  labelOpacity?: number;
  /**
   * The opacity of lines drawn to construct the board.
   */
  strokeOpacity?: number;
  /**
   * Used to add a solid block of colour behind the entire image. This should usually be left to the client, but sometimes you want the option.
   */
  backFill?: {
    /**
     * `full` just draws a rectangle behind the entire rendered field, including any labels. `board` only works for boards created from polygons and attempts to only draw the fill behind the board itself.
     */
    type?: "full" | "board";
    colour: Colourfuncs | Colourstrings;
    opacity?: number;
  };
  /**
   * On `squares*` boards, blacks out the specified cells and disables clicking. For hex grids, the hex simply isn't drawn. Like with `annotations`, the renderer knows nothing about a game's notation. You must provide instead the column and row numbers, which are zero-based: 0,0 is the top row, top column.
   *
   * @minItems 1
   */
  blocked?: [RowCol, ...RowCol[]];
  /**
   * Only meaningful for the 'hex_of_*' styles. Determines the minimum width at the top and bottom of the board.
   */
  minWidth?: number;
  /**
   * Only meaningful for the 'hex_as_*' styles. Determines the maximum width at the centre of the board.
   */
  maxWidth?: number;
  /**
   * Only meaningful for the `hex-of-*` boards. Tells the system to only render the top or bottom half of the hex, letting you build things like triangles and some rhomboids. Mutually exclusive with `alternatingSymmetry`.
   */
  half?: "top" | "bottom";
  /**
   * Required for the `squares*`, `vertex`, and `go` styles. For `circular-*` boards, specifies the number of slices.
   */
  width?: number;
  /**
   * Required for the `squares*`, `vertex`, and `go` styles. For `circular-*` boards, specifies the number of rings.
   */
  height?: number;
  /**
   * Only applies to the `sowing` board style. Determines whether to include full-height end pits on the board.
   */
  showEndPits?: boolean;
  /**
   * Only applies to the `sowing` board style. By default, pits have rounded corners. In games like Bao, specific spaces are distinct. This property tells the renderer the row and column of these spaces.
   *
   * @minItems 1
   */
  squarePits?: [RowCol, ...RowCol[]];
  /**
   * Only meaningful for the `squares*` and `vertex` boards. Defines the size (in board square units) of the clickable area around left and right sides of the board. So an invisisble 'bearing off' area.
   */
  clickDeltaX?: number;
  /**
   * Only meaningful for the `squares*` and `vertex` boards. Defines the size (in board square units) of the clickable area above and below the board. So an invisisble 'bearing off' area.
   */
  clickDeltaY?: number;
  /**
   * Only meaningful for the `squares-checkered` boards. Determines whether the first row start with a light or dark square.
   */
  startLight?: boolean;
  /**
   * Only meaningful for `hex-of-*` boards and generates configurations where the sides alternate between two sizes. Mutually exclusive with `half`.
   */
  alternatingSymmetry?: boolean;
  /**
   * An optional array of strings to override the default column labeling.
   */
  columnLabels?: string[];
  /**
   * An optional array of strings to override the default row labeling.
   */
  rowLabels?: string[];
  /**
   * Currently only applies to hex fields
   */
  labelStyle?: "internal" | "external";
  /**
   * A ham-fisted way to omit row and column labels you don't want displayed for some reason. Currently only used by the `triangles-stacked` renderer for certain board sizes.
   *
   * @minItems 1
   */
  skipLabels?: [string, ...string[]];
  /**
   * Only meaningful for the `squares` and `vertex` boards. Defines sections X cells wide as tiles. If `tileSpacing` is given, these tiles will be broken apart from each other. Otherwise, a heavier line is drawn to delineate.
   */
  tileWidth?: number;
  /**
   * Only meaningful for the `squares` and `vertex` boards. Defines sections X cells high as tiles. If `tileSpacing` is given, these tiles will be broken apart from each other. Otherwise, a heavier line is drawn to delineate.
   */
  tileHeight?: number;
  /**
   * If given, instead of drawing heavier lines to create tiles, it insteads breaks the boards into pieces and spreads them apart by this amount. This number represents the percent of one cell size. So a value of `1` is one cell size of spacing; `0.5` is half, `2` is double.
   */
  tileSpacing?: number;
  /**
   * Only valid for the `stacking-tiles` renderer. Specifies the maximum number of tiles allowed in a cell.
   */
  stackMax?: number;
  /**
   * Only valid for the `stacking-offset` renderer. A number between 0 and 1 representing the percentage of a cell's space that should be used to offset each piece in the stack. A value of 1 will lead to no overlap. A value of 0 will stack all the pieces directly on top of each other.
   */
  stackOffset?: number;
  /**
   * By default, circular boards start with a vertical line drawn from the centre straight "north". This lets you choose a different starting degree. In this plane, 0 degrees is towards the top of the screen and increases clockwise.
   */
  "circular-start"?: number;
  /**
   * For the `cairo-collinear` board, the top-left pair of pentagons can either be oriented horizontally or vertically.
   */
  cairoStart?: "H" | "V";
  /**
   * For the `snubsquare` board, lets you choose whether the top-right cell forms a square or a triangle. Default is square.
   */
  snubStart?: "S" | "T";
  /**
   * For the `squares-diamonds` board, the board edge can start with diamonds or squares (actually octagons). By default, the edges start with squares, but you can also start them with diamonds.
   */
  sdStart?: "S" | "D";
  /**
   * Adds a visible area around the outside of the board intended to be used with a click handler for bearing off pieces or other such interactions. Only applied to the `squares*`, `vertex*` and `go` boards. Uses the `strokeWeight/Colour/Opacity` options for the border, and can include an optional fill. The opacity and colour will also be applied to the fill.
   */
  buffer?: {
    /**
     * The width of the zone expressed as a percentage of the cell size. If zero, the zone is omitted.
     */
    width: number;
    pattern?: PatternName;
    /**
     * Choose which of the four sides you want displayed. By default, it's all four.
     */
    show?: ("N" | "E" | "S" | "W")[];
    /**
     * If true, the buffer is broken up into individual segments next to each cell, for fine-grained selection. Changes the data passed to the click handler.
     */
    separated?: boolean;
  };
  /**
   * Only meaningful in the `isometric` renderer where it gives the heights of the various cells of the board. The two-dimensional array needs to map to the chosen playing field. The heights can be arbitrary, and the glyphs are generated on the fly. The glyphs in the contact sheet are for playing pieces.
   *
   * @minItems 1
   */
  heightmap?: [[number, ...number[]], ...[number, ...number[]][]];
  /**
   * Sometimes a board needs shaded areas, lines showing ownership of board edges, things like that. This is how those are indicated. Not all features are available for all board styles.
   */
  markers?: (
    | MarkerDots
    | MarkerShading
    | MarkerFlood
    | MarkerOutline
    | MarkerHalo
    | MarkerLine
    | MarkerLabel
    | MarkerEdge
    | MarkerFence
    | MarkerFences
    | MarkerGlyph
  )[];
}
/**
 * The renderer is not aware of game notation. Nodes must be specified by row and column, with the top row being 0 and the left column being 0.
 */
export interface RowCol {
  row: number;
  col: number;
}
export interface MarkerDots {
  /**
   * A way of placing small marker dots at certain points of the board.
   */
  type: "dots";
  /**
   * Like with `annotations`, the renderer knows nothing about a game's notation. You must provide instead the column and row numbers, which are zero-based: 0,0 is the top row, top column.
   *
   * @minItems 1
   */
  points: [RowCol, ...RowCol[]];
  /**
   * The size of the diameter of the dot as a fraction of cellsize.
   */
  size?: number;
  /**
   * The colour of the shaded area. Can be either a number (which will be interpreted as a built-in player colour) or a hexadecimal colour string.
   */
  colour?: PositiveInteger | Colourfuncs | Colourstrings;
  /**
   * 1 is fully opaque. 0 is fully transparent.
   */
  opacity?: number;
}
export interface MarkerShading {
  /**
   * This is for shading spaces or areas on the board.
   */
  type: "shading";
  /**
   * If true, the shading will be done below the grid lines.
   */
  belowGrid?: boolean;
  /**
   * It expects at least three points, forming an auto-closed polygon. Board styles where a point is the center of a space (like the `squares` board style) instead point to the top-left corner of the space. Some experimentation may be required to enclose the area you want.
   *
   * @minItems 3
   */
  points: [RowCol, RowCol, RowCol, ...RowCol[]];
  /**
   * The colour of the shaded area. Can be either a number (which will be interpreted as a built-in player colour) or a hexadecimal colour string.
   */
  colour?: PositiveInteger | Colourfuncs | Colourstrings;
  /**
   * 1 is fully opaque. 0 is fully transparent.
   */
  opacity?: number;
}
export interface MarkerFlood {
  /**
   * Only usable by board styles composed of polygons. Distinct from shading, this will simply fill the specified cells with a colour.
   */
  type: "flood";
  /**
   * If true, places the flood fill before the gridlines. If a filled `halo` marker is present, that must appear before the flood fills.
   */
  belowGrid?: boolean;
  /**
   * One or more grid coordinates of spaces to fill.
   *
   * @minItems 1
   */
  points: [RowCol, ...RowCol[]];
  /**
   * The colour of the shaded area. Can be either a number (which will be interpreted as a built-in player colour) or a hexadecimal colour string.
   */
  colour?: PositiveInteger | Colourfuncs | Colourstrings | Gradient;
  pattern?: PatternName;
  /**
   * 1 is fully opaque. 0 is fully transparent.
   */
  opacity?: number;
  /**
   * Makes the the fill pulse opacity over the defined interval in milliseconds
   */
  pulse?: number;
}
export interface MarkerOutline {
  /**
   * Only usable by boards constructed out of premade shapes (e.g., `hex-of-hex`, `sowing`). Uses the given colour as the outline of the given cell shape.
   */
  type: "outline";
  /**
   * One or more grid coordinates of spaces to fill.
   *
   * @minItems 1
   */
  points: [RowCol, ...RowCol[]];
  /**
   * The colour of the shaded area. Can be either a number (which will be interpreted as a built-in player colour) or a hexadecimal colour string.
   */
  colour: PositiveInteger | Colourfuncs | Colourstrings;
  /**
   * 1 is fully opaque. 0 is fully transparent.
   */
  opacity?: number;
  /**
   * A valid `dasharray` appropriate for the game's display.
   */
  dasharray?: number[];
}
export interface MarkerHalo {
  /**
   * Only used for `circular-*` and `conical-hex*` boards. Draws an encompassing circle around the board, usually used to indicate ownership of segments
   */
  type: "halo";
  /**
   * If only one segment is given, then a single circle will be drawn. Otherwise, the circle will be divided into equal chunks and drawn in the order specified, proceeding clockwise. The first segment will align with the `circular-start` given in `board` (`0` by default).
   *
   * @minItems 1
   */
  segments: [
    {
      /**
       * The colour of the line. Can be either a number (which will be interpreted as a built-in player colour) or a hexadecimal colour string.
       */
      colour: PositiveInteger | Colourfuncs | Colourstrings;
      /**
       * 1 is fully opaque. 0 is fully transparent.
       */
      opacity?: number;
      style?: "solid" | "dashed";
    },
    ...{
      /**
       * The colour of the line. Can be either a number (which will be interpreted as a built-in player colour) or a hexadecimal colour string.
       */
      colour: PositiveInteger | Colourfuncs | Colourstrings;
      /**
       * 1 is fully opaque. 0 is fully transparent.
       */
      opacity?: number;
      style?: "solid" | "dashed";
    }[]
  ];
  /**
   * Stroke width of the line
   */
  width?: number;
  /**
   * By default, the halo aligns with the board sections (see `circular-start`). Sometimes you want to offset them. Provide the offset in absolute degrees, with positive numbers rotating clockwise.
   */
  offset?: number;
  /**
   * By default, the halo is centred on the centre of the combined polygons, but with 'limping' boards, the centre needs to be nudged. This is how you do it.
   */
  nudge?: {
    dx: number;
    dy: number;
  };
  /**
   * Fill is drawn before grid lines, segments are drawn after grid lines.
   */
  fill?: PositiveInteger | Colourfuncs | Colourstrings;
}
export interface MarkerLine {
  /**
   * A way of drawing arbitrary lines on the board. By default, respects the stroke width, colour, and opacity of the larger board.
   */
  type: "line";
  /**
   * Expects exactly two points. Board styles where a point is the center of a space (like the `squares` board style) instead point to the top-left corner of the space. Some experimentation may be required.
   *
   * @minItems 2
   * @maxItems 2
   */
  points: [RowCol, RowCol];
  /**
   * The colour of the line. Can be either a number (which will be interpreted as a built-in player colour) or a hexadecimal colour string.
   */
  colour?: PositiveInteger | Colourfuncs | Colourstrings;
  /**
   * 1 is fully opaque. 0 is fully transparent.
   */
  opacity?: number;
  /**
   * Stroke width of the line
   */
  width?: number;
  style?: "solid" | "dashed";
  /**
   * A valid `dasharray` appropriate for the game's display.
   */
  dasharray?: number[];
  /**
   * By default, on boards like `squares*`, lines anchor to the top-left corner of the cell. If `centered` is true, it will instead anchor to the centre point of the cell.
   */
  centered?: boolean;
  /**
   * Adds a click handler to the line. This can get in the way of regular clicks, depending on how your board is configured.
   */
  clickable?: boolean & string;
  /**
   * If true, the labels will be drawn below the grid lines.
   */
  belowGrid?: boolean;
  /**
   * Let's you trim the ends of a line. Expressed as a percentage of total length.
   */
  shorten?: number;
}
export interface MarkerLabel {
  /**
   * A ham-fisted way of getting arbitrary labels on a board or series of boards (e.g., Wizard's Garden). Experimentation will definitely be needed to accomplish your goal.
   */
  type: "label";
  /**
   * If true, the labels will be drawn below the grid lines.
   */
  belowGrid?: boolean;
  /**
   * The string itself you want to display.
   */
  label: string;
  /**
   * Expects exactly two points. This defines a line along which the text will flow and be centred along, as best as we can.
   *
   * @minItems 2
   * @maxItems 2
   */
  points: [RowCol, RowCol];
  /**
   * You almost never want a label *on* the board. Nudge lets you use board coordinates to get started and then move that line by a multiple of the 'cellspacing' (i.e., the base unit, the width of a square in a square grid). The nudge is applied to both points.
   */
  nudge?: {
    dx: number;
    dy: number;
  };
  /**
   * The colour of the shaded area. Can be either a number (which will be interpreted as a built-in player colour) or a hexadecimal colour string.
   */
  colour?: PositiveInteger | Colourfuncs | Colourstrings;
  /**
   * Font size in absolute pixels
   */
  size?: number;
  /**
   * Font style, e.g. 'font: Stencil; font-weight: Bold'
   */
  font?: string;
}
export interface MarkerEdge {
  /**
   * This will highlight one edge of the board, indicated by compass direction. It relies on the properties`strokeWeight` and `strokeOpacity`, if given. It does not work on the `hex-odd*`, `hex-even*`, `hex-of-cir` or `hex-of-hex` boards.
   */
  type: "edge";
  /**
   * An invalid edge designator (NE on a square map, for example) will just be ignored.
   */
  edge: "N" | "NE" | "E" | "SE" | "S" | "SW" | "W" | "NW";
  /**
   * The colour of the shaded area. Can be either a number (which will be interpreted as a built-in player colour) or a hexadecimal colour string.
   */
  colour: PositiveInteger | Colourfuncs | Colourstrings;
  opacity?: number;
}
export interface MarkerFence {
  /**
   * Only works for the `squares*` and rect-of-hex board styles. Draws a thick line between two adjacent cells. It doesn't check adjacency, but the results will not be what you expect otherwise.
   */
  type: "fence";
  cell: RowCol;
  side: "N" | "NE" | "E" | "SE" | "S" | "SW" | "W" | "NW";
  /**
   * The colour of the fence. Can be either a number (which will be interpreted as a built-in player colour) or a hexadecimal colour string.
   */
  colour?: PositiveInteger | Colourfuncs | Colourstrings;
  /**
   * Expressed as a multiple of the base stroke width
   */
  width?: number;
  /**
   * A valid `dasharray` appropriate for the game's display.
   */
  dashed?: number[];
}
/**
 * Just a container marker for multiple fences
 */
export interface MarkerFences {
  type: "fences";
  /**
   * @minItems 1
   */
  sides: [MarkerFenceData, ...MarkerFenceData[]];
}
export interface MarkerFenceData {
  cell: RowCol;
  side: "N" | "NE" | "E" | "SE" | "S" | "SW" | "W" | "NW";
  /**
   * The colour of the fence. Can be either a number (which will be interpreted as a built-in player colour) or a hexadecimal colour string.
   */
  colour?: PositiveInteger | Colourfuncs | Colourstrings;
  /**
   * Expressed as a multiple of the base stroke width
   */
  width?: number;
  /**
   * A valid `dasharray` appropriate for the game's display.
   */
  dashed?: number[];
}
export interface MarkerGlyph {
  /**
   * A way of incorporating a glyph from the legend into the board itself. Currently only works in the `default` and `stacking-offset` renderer.
   */
  type: "glyph";
  /**
   * If true, the glyph will be drawn below the grid lines.
   */
  belowGrid?: boolean;
  /**
   * The name of the glyph in the `legend`.
   */
  glyph: string;
  /**
   * Like with `annotations`, the renderer knows nothing about a game's notation. You must provide instead the column and row numbers, which are zero-based: 0,0 is the top row, top column.
   *
   * @minItems 1
   */
  points: [RowCol, ...RowCol[]];
}
/**
 * The board schema for the `entropy` renderer
 */
export interface BoardEntropy {
  style: "entropy";
  /**
   * Describes the left-hand or top board
   */
  boardOne?: {
    label?: string;
    /**
     * Used as an aid to the player by occluding one of the boards
     */
    occluded?: boolean;
  };
  /**
   * Describes the right-hand or bottom board
   */
  boardTwo?: {
    label?: string;
    /**
     * Used as an aid to the player by occluding one of the boards
     */
    occluded?: boolean;
  };
  /**
   * Whether the two boards should be arranged horizontally or vertically
   */
  orientation?: "horizontal" | "vertical";
  /**
   * The base stroke weight of lines drawn to construct the board.
   */
  strokeWeight?: number;
  /**
   * Pattern for hex colour strings
   */
  strokeColour?: string;
  /**
   * The opacity of lines drawn to construct the board, includes the labels.
   */
  strokeOpacity?: number;
}
/**
 * Board schema for `freespace` boards
 */
export interface BoardFreespace {
  /**
   * Width in pixels of the visible field. The total SVG size will likely be larger, especially if you include areas or other features.
   */
  width: number;
  /**
   * Width in pixels of the visible field. The total SVG size will likely be larger, especially if you include areas or other features.
   */
  height: number;
  /**
   * Used to add a solid block of colour behind the entire image. This should usually be left to the client, but sometimes you want the option.
   */
  backFill?: {
    /**
     * `full` just draws a rectangle behind the entire rendered field, including any labels. `board` only works for boards created from polygons and attempts to only draw the fill behind the board itself.
     */
    type?: "full" | "board";
    colour: Colourfuncs | Colourstrings;
    opacity?: number;
  };
  /**
   * In most cases, you'll want the top-left corner of the field to be 0,0 and generate your render accordingly. But if for some reason you want that origin to be different, change it here.
   */
  origin?: {
    x?: number;
    y?: number;
  };
  /**
   * Markers are placed before pieces, and thus can be obscured by them.
   */
  markers?: (MarkerPath | MarkerFreespaceLabel | MarkerFreespaceGlyph)[];
}
/**
 * A simple SVG path with stroke and fill attributes.
 */
export interface MarkerPath {
  type: "path";
  path: string;
  fill?: PositiveInteger | Colourfuncs | Colourstrings;
  fillOpacity?: number;
  stroke?: PositiveInteger | Colourfuncs | Colourstrings;
  strokeWidth?: number;
  strokeOpacity?: number;
  /**
   * A valid `dasharray` appropriate for the game's display.
   */
  dashed?: number[];
}
export interface MarkerFreespaceLabel {
  /**
   * A ham-fisted way of getting arbitrary labels on a board or series of boards (e.g., Wizard's Garden). Experimentation will definitely be needed to accomplish your goal.
   */
  type: "label";
  /**
   * The string itself you want to display.
   */
  label: string;
  /**
   * Expects exactly two points. This defines a line along which the text will flow and be centred along, as best as we can.
   *
   * @minItems 2
   * @maxItems 2
   */
  points: [
    {
      x: number;
      y: number;
    },
    {
      x: number;
      y: number;
    }
  ];
  /**
   * The colour of the shaded area. Can be either a number (which will be interpreted as a built-in player colour) or a hexadecimal colour string.
   */
  colour?: PositiveInteger | Colourfuncs | Colourstrings;
  /**
   * Font size in absolute pixels
   */
  size?: number;
}
export interface MarkerFreespaceGlyph {
  /**
   * A way of incorporating a glyph from the legend into the board itself.
   */
  type: "glyph";
  /**
   * The name of the glyph in the `legend`.
   */
  glyph: string;
  orientation?: number;
  /**
   * Provide absolute x,y coordinates.
   *
   * @minItems 1
   */
  points: [
    {
      x: number;
      y: number;
    },
    ...{
      x: number;
      y: number;
    }[]
  ];
}
/**
 * Schema for the `freespace` renderer. This maps glyphs from the legend directly onto the playing field at given x,y coordinates, oriented in a specific direction. Pieces that fall outside of the visible field (defined by the board's `width`, `height`, and `origin` will not be visible. Any transformations applied in the legend (like rotation) are applied *before* any rotation caused by orientations given here.
 */
export interface Freepiece {
  /**
   * The name of the glyph. Must appear in the legend. Can be composed and transformed just as for any other renderer.
   */
  glyph: string;
  /**
   * A unique ID that should be passed to the click handler. If not provided, it will just return the glyph name.
   */
  id?: string;
  /**
   * Absolute x coordinate of the centre of the glyph. Glyphs placed outside of the visible playing area will not appear.
   */
  x: number;
  /**
   * Absolute y coordinate of the centre of the glyph. Glyphs placed outside of the visible playing area will not appear.
   */
  y: number;
  /**
   * Expressed in degrees, relative to 0&deg; being towards the top of the display and postive rotation moving in a clockwise direction. So the glyph is placed as composed in the legend and then rotated. 90&deg; would turn the glyph to the right. Negative degrees are fine.
   */
  orientation?: number;
}
/**
 * Schema for the `multicell-square` renderer. This deforms glyphs from the legend into rectangular areas anchored from the top-left cell (the x,y coordinates closest to 0,0) and in a given width and height. Pieces can be overlapped, with an order decided by z index (higher z indices will overlap lower ones).
 */
export interface Multipiece {
  /**
   * The name of the glyph. Must appear in the legend. Can be composed and transformed just as for any other renderer.
   */
  glyph: string;
  /**
   * A unique ID that should be passed to the click handler. If not provided, it will return an ID based on the other attributes.
   */
  id?: string;
  /**
   * The column of the top-left corner of the rectangle (the column closest to 0).
   */
  col: number;
  /**
   * The row of the top-left corner of the rectangle (the closest row to 0).
   */
  row: number;
  /**
   * The width of the rectangle.
   */
  width?: number;
  /**
   * The height of the rectangle.
   */
  height?: number;
  /**
   * Determines the order of overlap. Higher z values will overlap lower ones. Objects with equal z values will be rendered in the order of declaration (later objects will overlap earlier ones).
   */
  z?: number;
}
/**
 * Schema for the `polyomino` renderer.
 */
export interface Polypiece {
  /**
   * A unique ID that should be passed to the click handler. If not provided, it will return an ID based on the other attributes.
   */
  id?: string;
  /**
   * The column of the top-left corner of the matrix (the column closest to 0).
   */
  col: number;
  /**
   * The row of the top-left corner of the matrix (the closest row to 0).
   */
  row: number;
  matrix: Polymatrix;
  /**
   * Determines the order of overlap. Higher z values will overlap lower ones. Objects with equal z values will be rendered in the order of declaration (later objects will overlap earlier ones).
   */
  z?: number;
}
/**
 * The only area currently used by the default renderer. Given a list of pieces from the legend, it will place them all in a bar beneath the board. The pieces will be individually clickable. Current use is for tracking pieces being rearranged in Realm.
 */
export interface AreaPieces {
  type: "pieces";
  /**
   * A list of strings representing glyphs in the `legend`
   *
   * @minItems 1
   */
  pieces: [string, ...string[]];
  /**
   * The text that will appear at the top left of the area
   */
  label: string;
  /**
   * By default, the pieces area will wrap once it reaches the width of the game board itself. This lets you set a fixed width. Expressed as number of pieces.
   */
  width?: number;
  /**
   * Optional. A colour you want to shade the background with. Helpful when dealing with borderless pieces or weird colours.
   */
  background?: Colourstrings | Colourfuncs;
  /**
   * Optional. Places a coloured bar to the left of the area, used to indicate ownership.
   */
  ownerMark?: PositiveInteger | Colourfuncs | Colourstrings;
  /**
   * With some piece types, you need extra space between them. Expressed as a percentage of cell size, this will insert some padding between pieces.
   */
  spacing?: number;
}
/**
 * This is a special area currently only used for the DVGC games and incorporates a `pieces`-style area into the game board itself. It is currently only designed for two-player use with 180 degree rotation. The area is clickable, as are the pieces within. You must tell the renderer which area belongs to which player.
 */
export interface AreaReserves {
  type: "reserves";
  /**
   * A list of strings representing glyphs in the `legend`
   */
  pieces: string[];
  /**
   * What side of the board does this belong on
   */
  side: "N" | "S";
  /**
   * Optional. A colour you want to shade the background with. Helpful when dealing with borderless pieces or weird colours.
   */
  background: PositiveInteger | Colourfuncs | Colourstrings;
  /**
   * Optional. Places a coloured bar to the left of the area, used to indicate ownership.
   */
  ownerMark?: PositiveInteger | Colourfuncs | Colourstrings;
}
/**
 * Used by the `polyomino` renderer to display a selected piece and provide UI for manipulating it. Current maninpulations are rotating in 90-degree increments and flipping horizontally and vertically.
 */
export interface AreaPolyomino {
  type: "polyomino";
  label: string;
  matrix: Polymatrix;
  /**
   * Optional. A colour you want to shade the background with. Helpful when dealing with borderless pieces or weird colours.
   */
  background?: Colourfuncs | Colourstrings;
}
/**
 * The 'stash' definition for the homeworlds renderer. All colours must be specified. Empty strings represent empty stashes.
 */
export interface AreaHWStash {
  type: "globalStash";
  R: Stashstrings;
  G: Stashstrings;
  B: Stashstrings;
  Y: Stashstrings;
}
/**
 * Used by the `stacking-expanding` renderer to display the expanded contents of a cell.
 */
export interface AreaStackingExpanded {
  type: "expandedColumn";
  /**
   * The coordinates of the cell being expanded (optional).
   */
  cell?: string;
  /**
   * List of pieces (each must appear in the `legend`) to display alongside the board. The first piece in the array is the bottom of the stack.
   */
  stack: string[];
}
/**
 * Used by the `stacking-expanding` renderer for displaying stashes of pyramids (e.g., captured pieces in a Volcano game).
 */
export interface AreaVolcanoStash {
  type: "localStash";
  label: string;
  /**
   * This is an array of stacks of pieces (themselves an array).
   */
  stash: string[][];
}
/**
 * Used to create a button bar for clicking.
 */
export interface AreaButtonBar {
  type: "buttonBar";
  /**
   * The array of the buttons themselves, which will be presented in the order given.
   *
   * @minItems 1
   */
  buttons: [ButtonBarButton, ...ButtonBarButton[]];
  /**
   * Where you want the bar to appear relative to the board.
   */
  position?: "left" | "right";
  /**
   * The height of each button as a percentage of the cell size.
   */
  height?: number;
  /**
   * If you want the buttons to have a minimum width, regardless of the values, provide it here as a percentage of the cell size. Otherwise all the buttons will have the width of the widest label.
   */
  minWidth?: number;
  /**
   * The spacing you want between each button, expressed as a percentage of the height.
   */
  buffer?: number;
  /**
   * The colour of the button border and text.
   */
  colour?: Colourfuncs | Colourstrings;
}
export interface ButtonBarButton {
  /**
   * The label that will be visible on the rendered image.
   */
  label: string;
  /**
   * The value passed to the click handler as `_btn_X`, where `X` is the value here. If omitted, the label will be passed as is.
   */
  value?: string;
  /**
   * Lets you pass attributes to the `<text>` tag for things like strikethrough and italics. See the SVG spec for a list of applicable attributes.
   *
   * @minItems 1
   */
  attributes?: [
    {
      name: string;
      value: string;
    },
    ...{
      name: string;
      value: string;
    }[]
  ];
  /**
   * Optional fill for this specific button.
   */
  fill?: Colourfuncs | Colourstrings;
}
/**
 * Used to create a clickable vertical scroll bar used for hiding/showing layers of pieces.
 */
export interface AreaScrollBar {
  type: "scrollBar";
  /**
   * The lowest value of the bar (usually 0).
   */
  min?: number;
  /**
   * The highest value of the bar.
   */
  max: number;
  /**
   * The current value of the bar.
   */
  current?: number;
  /**
   * Defines the text labels for each of the clickable elements.
   */
  labels?: {
    upOne?: string;
    upAll?: string;
    downOne?: string;
    downAll?: string;
    bar?: string;
  };
  /**
   * Where you want the bar to appear relative to the board.
   */
  position?: "left" | "right";
  /**
   * The width of each scroll bar segment as a percentage of the cell size.
   */
  width?: number;
  /**
   * The height of each scroll bar segment as a percentage of the cell size.
   */
  height?: number;
  /**
   * By default, each segment is signalled by lines that extend beyond the width of the bar itself. This defines the extra width of that line, as a percentage of the total width.
   */
  lineWidth?: number;
  /**
   * Defines the various colour settings.
   */
  colours?: {
    /**
     * Pattern for hex colour strings
     */
    background?: string | string;
    /**
     * Pattern for hex colour strings
     */
    fill?: string | string;
    /**
     * Pattern for hex colour strings
     */
    strokes?: string | string;
  };
}
/**
 * Used to create a clickable compass rose for facing selection.
 */
export interface AreaCompassRose {
  type: "compassRose";
  /**
   * Where you want the rose to appear relative to the board.
   */
  position?: "left" | "right";
  /**
   * The width of the rose as a multiple of cellsize. Rose will be square.
   */
  width?: number;
}
/**
 * A list of pieces in the `legend` that players need identifiers for. Usually needed for games with many colours or just indicating who controls what.
 */
export interface AreaKey {
  type?: "key";
  /**
   * The list of piece ids (must exist in the `legend`) and a short string the user should associate with it. They will be listed in the order provided.
   */
  list: {
    piece: string;
    name: string;
    /**
     * If a click handler is attached, this is the value that will be given in the "piece" parameter. Otherwise it will pass the name.
     */
    value?: string;
  }[];
  /**
   * The height of each entry as a percentage of cell size.
   */
  height?: number;
  /**
   * The spacing you want between each entry, expressed as a percentage of the height.
   */
  buffer?: number;
  /**
   * Where you would prefer the legend be placed relative to the game board. Specific renderers may override your preference.
   */
  position?: "left" | "right";
  /**
   * By default, `key` entries have a click handler attached. Set this to `false` to disable that.
   */
  clickable?: boolean;
}
/**
 * These are pulled into the definitions section to make referencing them easier in the game code.
 */
export interface AnnotationBasic {
  /**
   * The type of annotation. `move` draws an arrow between two cells. `eject` draws ever-growing arcs between a sequence of cells. `enter` and `exit` both draw a dotted line around cells. `dots` draws a small dot in the given cells. `outline` expects at least three points and draws a dotted line around the outer edge of the defined polygon.
   */
  type: "move" | "eject" | "enter" | "exit" | "dots" | "outline" | "glyph" | "line";
  /**
   * The cells involved in the annotation
   *
   * @minItems 1
   */
  targets: [RowCol, ...RowCol[]];
  style?: "solid" | "dashed";
  /**
   * The width of the line, expressed as a percentage of cell size.
   */
  strokeWidth?: number;
  opacity?: number;
  colour?: Colourstrings | Colourfuncs | PositiveInteger;
  arrow?: boolean;
  /**
   * Whether the move annotation should have dot anchors.
   */
  anchors?: boolean;
  /**
   * The size of the diameter of the dot as a fraction of cellsize.
   */
  size?: number;
  /**
   * Only meaningful for the `eject` annotation. If true, it won't keep expanding the area of each consecutive arc.
   */
  static?: boolean & string;
  /**
   * Only meaningful for the `glyph` annotation. Places a glyph from the legend at the requested points.
   */
  glyph?: string;
  /**
   * A valid `dasharray` appropriate for the game's display.
   */
  dashed?: number[];
  /**
   * Only meaningful for the `enter` and `exit` notations. Determines the shape of the dotted line.
   */
  shape?: "square" | "circle" | "hexf" | "hexp";
  /**
   * Only meaningful for enter/exit notations. By default, a background is drawn before the dotted line. This isn't desireably in rare occasions where you want markers underneath the annotation to be visible.
   */
  occlude?: boolean;
}
/**
 * Delta annotations for the `sowing-*` renderers
 */
export interface AnnotationSowing {
  type: "deltas";
  deltas: {
    row: number;
    col: number;
    delta: number;
  }[];
}
export interface AnnotationHomeworlds {
  /**
   * Name of the system
   */
  system: string;
  /**
   * The index of the colour, indicating the action used (1 = Red, 2 = Blue, 3 = Green, 4 = Yellow)
   */
  action: number;
}
