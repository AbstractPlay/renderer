{
    "$schema": "http://json-schema.org/schema#",
    "$id": "https://www.abstractplay.com/schemas/rendergame/0-7-0.json#",
    "title": "AP Render Rep",
    "description": "Games on the Abstract Play service must produce representations of the play area based on this schema. The front-end renderer will then translate that into various forms. Detailed documentation is difficult within a JSON document (e.g., no multi-line strings allowed), so see the website for standalone documentation.",
    "$defs": {
        "positiveInteger": {
            "type": "integer",
            "minimum": 1
        },
        "positiveNumber": {
            "type": "number",
            "exclusiveMinimum": 0
        },
        "stashstrings": {
            "description": "Pattern for the global stash definitions for the `homeworlds` renderer.",
            "type": "string",
            "pattern": "^1*2*3*$"
        },
        "colourstrings": {
            "description": "Pattern for hex colour strings",
            "anyOf": [
                {
                    "type": "string",
                    "pattern": "^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$"
                },
                {
                    "type": "string",
                    "pattern": "^_context_"
                }
            ]
        },
        "rowCol": {
            "description": "The renderer is not aware of game notation. Nodes must be specified by row and column, with the top row being 0 and the left column being 0.",
            "type": "object",
            "properties": {
                "row": {
                    "type": "number",
                    "minimum": 0
                },
                "col": {
                    "type": "number",
                    "minimum": 0
                }
            },
            "required": ["row", "col"],
            "additionalProperties": false
        },
        "boardStyles": {
            "enum": [
                "squares",
                "squares-checkered",
                "squares-beveled",
                "squares-stacked",
                "squares-diamonds",
                "vertex",
                "vertex-cross",
                "vertex-fanorona",
                "pegboard",
                "hex-slanted",
                "hex-odd-p",
                "hex-even-p",
                "hex-odd-f",
                "hex-even-f",
                "hex-of-hex",
                "hex-of-tri",
                "hex-of-cir",
                "snubsquare",
                "circular-cobweb",
                "circular-moon",
                "sowing",
                "conhex-dots",
                "conhex-cells",
                "cairo-collinear",
                "cairo-catalan",
                "triangles-stacked",
                "conical-hex",
                "conical-hex-narrow",
                "pyramid-hex",
                "heightmap-squares",
                "dvgc",
                "dvgc-checkered"
            ]
        },
        "gradientStop": {
            "description": "Schema for a gradient stop",
            "type": "object",
            "properties": {
                "offset": {
                    "description": "Interpreted as a percent, like opacity",
                    "type": "number",
                    "minimum": 0,
                    "maximum": 1
                },
                "colour": {
                    "description": "Hex string or player number of the desired colour",
                    "anyOf": [
                        {"$ref": "#/$defs/positiveInteger"},
                        {"$ref": "#/$defs/colourstrings"}
                    ]
                },
                "opacity": {
                    "type": "number",
                    "minimum": 0,
                    "maximum": 1,
                    "default": 1
                }
            },
            "required": ["offset", "colour"],
            "additionalProperties": false
        },
        "gradient": {
            "description": "A gradient one can use for flood fills and the like.",
            "type": "object",
            "properties": {
                "x1": {
                    "type": "number",
                    "minimum": 0,
                    "maximum": 1,
                    "default": 0
                },
                "y1": {
                    "type": "number",
                    "minimum": 0,
                    "maximum": 1,
                    "default": 0
                },
                "x2": {
                    "type": "number",
                    "minimum": 0,
                    "maximum": 1,
                    "default": 1
                },
                "y2": {
                    "type": "number",
                    "minimum": 0,
                    "maximum": 1,
                    "default": 0
                },
                "stops": {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/gradientStop"
                    },
                    "minItems": 2
                }
            },
            "required": ["stops"],
            "additionalProperties": false
        },
        "glyph": {
            "description": "An individual glyph with options, used in the `legend` property.",
            "type": "object",
            "properties": {
                "name": {
                    "description": "The name of the actual glyph. It may not contain any whitespace.",
                    "type": "string",
                    "pattern": "^\\S+$"
                },
                "text": {
                    "description": "Mutually exclusive with `name`. In this case, the glyph is plain text, shrunk down to the appropriate size to fit in a cell. This is intended for very short strings, like numbers.",
                    "type": "string"
                },
                "colour": {
                    "description": "A 3- or 6-digit hex colour value, a player position, or a gradient.",
                    "anyOf": [
                        {"$ref": "#/$defs/colourstrings"},
                        {"$ref": "#/$defs/positiveInteger"},
                        {"$ref": "#/$defs/gradient"}
                    ]
                },
                "scale": {
                    "description": "A number representing how you want the glyph proportionately scaled. Numbers <1 will shrink the glyph. Numbers >1 will enlarge it.",
                    "type": "number",
                    "default": 1
                },
                "opacity": {
                    "description": "A number between 0 and 1 indicating how opaque to render the glyph. A value of 0 means completely transparent.",
                    "type": "number",
                    "minimum": 0,
                    "maximum": 1,
                    "default": 1
                },
                "rotate": {
                    "description": "A number between -360 and 360 representing the degrees to rotate the glyph. Negative values rotate counterclockwise.",
                    "anyOf": [
                        {
                            "type": "number",
                            "minimum": -360,
                            "maximum": 360
                        },
                        {"type": "null"}
                    ],
                    "default": 0
                },
                "orientation": {
                    "description": "Determines how the piece (usually a text element) is reorientated after rotation is done. 'vertical' means it will always be reorientated vertically. Otherwise, it rotates along with everything else.",
                    "enum": ["vertical", "fluid"],
                    "default": "fluid"
                },
                "nudge" : {
                    "description": "The number of units to nudge the glyph from centre.",
                    "type": "object",
                    "properties": {
                        "dx": {
                            "description": "Negative values move the glyph to the left.",
                            "type": "number",
                            "default": 0
                        },
                        "dy": {
                            "description": "Negative values move the glyph up.",
                            "type": "number",
                            "default": 0
                        }
                    },
                    "additionalProperties": false
                }
            },
            "additionalProperties": false
        },
        "polymatrix": {
            "description": "Schema for the `matrix` part of a polyomino-related feature",
            "type": "array",
            "items": {
                "type": "array",
                "items": {
                    "anyOf": [
                        {"$ref": "#/$defs/positiveInteger"},
                        {"$ref": "#/$defs/colourstrings"},
                        {
                            "type": "number",
                            "enum": [0]
                        },
                        {
                            "type": "null"
                        }
                    ]
                }
            }
        },
        "polypiece": {
            "description": "Schema for the `polyomino` renderer.",
            "type": "object",
            "properties": {
                "id": {
                    "description": "A unique ID that should be passed to the click handler. If not provided, it will return an ID based on the other attributes.",
                    "type": "string"
                },
                "col": {
                    "description": "The column of the top-left corner of the matrix (the column closest to 0).",
                    "type": "number"
                },
                "row": {
                    "description": "The row of the top-left corner of the matrix (the closest row to 0).",
                    "type": "number"
                },
                "matrix": {
                    "$ref": "#/$defs/polymatrix"
                },
                "z": {
                    "description": "Determines the order of overlap. Higher z values will overlap lower ones. Objects with equal z values will be rendered in the order of declaration (later objects will overlap earlier ones).",
                    "type": "number",
                    "default": 0
                }
            },
            "required": ["col", "row", "matrix"],
            "additionalProperties": false
        },
        "isometricPieces": {
            "description": "The types of pieces supported in an isometric legend.",
            "enum": ["cube", "cylinder", "hexp", "hexf", "lintelN", "lintelE", "lintelS", "lintelW", "lintelNS", "lintelEW", "spaceCube"]
        },
        "isoPiece": {
            "description": "Schema for a single piece in an `isoPieces` object.",
            "type": "object",
            "properties": {
                "piece": {"$ref": "#/$defs/isometricPieces"},
                "height": {
                    "type": "number",
                    "minimum": 0,
                    "default": 0
                },
                "colour": {
                    "anyOf": [
                        {"$ref": "#/$defs/colourstrings"},
                        {"$ref": "#/$defs/positiveInteger"}
                    ],
                    "default": "#000"
                },
                "scale": {
                    "description": "As a percentage of the cell size. By default, pieces are shrunk by 25% within the cell.",
                    "type": "number",
                    "minimum": 0,
                    "default": 0.75
                }
            },
            "required": ["piece", "height", "colour"],
            "additionalProperties": false
        },
        "annotationBasic": {
            "description": "These are pulled into the definitions section to make referencing them easier in the game code.",
            "type": "object",
            "properties": {
                "type": {
                    "description": "The type of annotation. `move` draws an arrow between two cells. `eject` draws ever-growing arcs between a sequence of cells. `enter` and `exit` both draw a dotted line around cells. `dots` draws a small dot in the given cells. `outline` expects at least three points and draws a dotted line around the outer edge of the defined polygon.",
                    "enum": [
                        "move",
                        "eject",
                        "enter",
                        "exit",
                        "dots",
                        "outline",
                        "glyph"
                    ]
                },
                "targets": {
                    "description": "The cells involved in the annotation",
                    "type": "array",
                    "minItems": 1,
                    "items": {"$ref": "#/$defs/rowCol"}
                },
                "style": {
                    "enum": [
                        "solid",
                        "dashed"
                    ],
                    "default": "solid"
                },
                "strokeWidth": {
                    "description": "The width of the line, expressed as a percentage of cell size.",
                    "type": "number",
                    "minimum": 0,
                    "default": 0.03
                },
                "opacity": {
                    "type": "number",
                    "minimum": 0,
                    "maximum": 1,
                    "default": 1
                },
                "colour": {
                    "anyOf": [
                        {"$ref": "#/$defs/colourstrings"},
                        {"$ref": "#/$defs/positiveInteger"}
                    ],
                    "default": "#000"
                },
                "arrow": {
                    "type": "boolean",
                    "default": true
                },
                "anchors": {
                    "description": "Whether the move annotation should have dot anchors.",
                    "type": "boolean",
                    "default": true
                },
                "size": {
                    "description": "The size of the diameter of the dot as a fraction of cellsize.",
                    "type": "number",
                    "default": 0.2
                },
                "static": {
                    "description": "Only meaningful for the `eject` annotation. If true, it won't keep expanding the area of each consecutive arc.",
                    "type": "boolean",
                    "default": "true"
                },
                "glyph": {
                    "description": "Only meaningful for the `glyph` annotation. Places a glyph from the legend at the requested points.",
                    "type": "string"
                },
                "dashed": {
                    "description": "A valid `dasharray` appropriate for the game's display.",
                    "type": "array",
                    "items": {
                        "type": "number"
                    }
                }
            },
            "required": ["type", "targets"],
            "additionalProperties": false
        },
        "annotationSowing": {
            "description": "Delta annotations for the `sowing-*` renderers",
            "type": "object",
            "properties": {
                "type": {
                    "enum": ["deltas"]
                },
                "deltas": {
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "row": {
                                "type": "integer"
                            },
                            "col": {
                                "type": "integer"
                            },
                            "delta": {
                                "type": "integer"
                            }
                        },
                        "required": ["row", "col", "delta"],
                        "additionalProperties": false
                    }
                }
            },
            "required": ["type", "deltas"],
            "additionalProperties": false
        },
        "annotationHomeworlds": {
            "type": "object",
            "properties": {
                "system": {
                    "description": "Name of the system",
                    "type": "string"
                },
                "action": {
                    "description": "The index of the colour, indicating the action used (1 = Red, 2 = Blue, 3 = Green, 4 = Yellow)",
                    "type": "integer",
                    "minimum": 1,
                    "maximum": 4
                }
            },
            "required": ["system", "action"],
            "additionalProperties": false
        },
        "annotationFreespace": {
            "description": "Annotations specifically for the `freespace` renderer.",
            "type": "object",
            "anyOf": [
                {
                    "description": "Path annotations are simply an SVG path with stroke and fill attributes. You can draw whatever annotations you want. They will overlie any pieces.",
                    "properties": {
                        "type": {
                            "enum": ["path"]
                        },
                        "path": {
                            "type": "string"
                        },
                        "fill": {
                            "anyOf": [
                                {"$ref": "#/$defs/positiveInteger"},
                                {"$ref": "#/$defs/colourstrings"}
                            ],
                            "default": "#fff"
                        },
                        "fillOpacity": {
                            "type": "number",
                            "minimum": 0,
                            "maximum": 1,
                            "default": 1
                        },
                        "stroke": {
                            "anyOf": [
                                {"$ref": "#/$defs/positiveInteger"},
                                {"$ref": "#/$defs/colourstrings"}
                            ],
                            "default": "#000"
                        },
                        "strokeWidth": {
                            "type": "number",
                            "minimum": 0.1,
                            "default": 1
                        },
                        "strokeOpacity": {
                            "type": "number",
                            "minimum": 0,
                            "maximum": 1,
                            "default": 1
                        },
                        "dashed": {
                            "description": "A valid `dasharray` appropriate for the game's display.",
                            "type": "array",
                            "items": {
                                "type": "number"
                            }
                        }
                    },
                    "required": ["type", "path"],
                    "additionalProperties": false
                },
                {
                    "properties": {
                        "type": {
                            "description": "A way of incorporating a glyph from the legend into the board itself. This one is specific to the `freespace` renderer.",
                            "enum": ["glyph"]
                        },
                        "glyph": {
                            "description": "The name of the glyph in the `legend`.",
                            "type": "string"
                        },
                        "points": {
                            "description": "Provide absolute x,y coordinates.",
                            "type": "array",
                            "items": {
                                "type": "object",
                                "properties": {
                                    "x": {
                                        "type": "number"
                                    },
                                    "y": {
                                        "type": "number"
                                    }
                                },
                                "required": ["x","y"],
                                "additionalProperties": false
                            },
                            "minItems": 1
                        }
                    },
                    "required": ["type", "glyph", "points"],
                    "additionalProperties": false
                }
            ]
        },
        "multipiece": {
            "description": "Schema for the `multicell-square` renderer. This deforms glyphs from the legend into rectangular areas anchored from the top-left cell (the x,y coordinates closest to 0,0) and in a given width and height. Pieces can be overlapped, with an order decided by z index (higher z indices will overlap lower ones).",
            "type": "object",
            "properties": {
                "glyph": {
                    "description": "The name of the glyph. Must appear in the legend. Can be composed and transformed just as for any other renderer.",
                    "type": "string"
                },
                "id": {
                    "description": "A unique ID that should be passed to the click handler. If not provided, it will return an ID based on the other attributes.",
                    "type": "string"
                },
                "col": {
                    "description": "The column of the top-left corner of the rectangle (the column closest to 0).",
                    "type": "number"
                },
                "row": {
                    "description": "The row of the top-left corner of the rectangle (the closest row to 0).",
                    "type": "number"
                },
                "width": {
                    "description": "The width of the rectangle.",
                    "type": "number",
                    "default": 1
                },
                "height": {
                    "description": "The height of the rectangle.",
                    "type": "number",
                    "default": 1
                },
                "z": {
                    "description": "Determines the order of overlap. Higher z values will overlap lower ones. Objects with equal z values will be rendered in the order of declaration (later objects will overlap earlier ones).",
                    "type": "number",
                    "default": 0
                }
            },
            "required": ["glyph", "col", "row"],
            "additionalProperties": false
        },
        "freepiece": {
            "description": "Schema for the `freespace` renderer. This maps glyphs from the legend directly onto the playing field at given x,y coordinates, oriented in a specific direction. Pieces that fall outside of the visible field (defined by the board's `width`, `height`, and `origin` will not be visible. Any transformations applied in the legend (like rotation) are applied *before* any rotation caused by orientations given here.",
            "type": "object",
            "properties": {
                "glyph": {
                    "description": "The name of the glyph. Must appear in the legend. Can be composed and transformed just as for any other renderer.",
                    "type": "string"
                },
                "id": {
                    "description": "A unique ID that should be passed to the click handler. If not provided, it will just return the glyph name.",
                    "type": "string"
                },
                "x": {
                    "description": "Absolute x coordinate of the centre of the glyph. Glyphs placed outside of the visible playing area will not appear.",
                    "type": "number"
                },
                "y": {
                    "description": "Absolute y coordinate of the centre of the glyph. Glyphs placed outside of the visible playing area will not appear.",
                    "type": "number"
                },
                "orientation": {
                    "description": "Expressed in degrees, relative to 0&deg; being towards the top of the display and postive rotation moving in a clockwise direction. So the glyph is placed as composed in the legend and then rotated. 90&deg; would turn the glyph to the right. Negative degrees are fine.",
                    "type": "number",
                    "default": 0
                }
            },
            "required": ["glyph", "x", "y"],
            "additionalProperties": false
        },
        "areaPieces": {
            "description": "The only area currently used by the default renderer. Given a list of pieces from the legend, it will place them all in a bar beneath the board. The pieces will be individually clickable. Current use is for tracking pieces being rearranged in Realm.",
            "type": "object",
            "properties": {
                "type": {
                    "enum": ["pieces"]
                },
                "pieces": {
                    "description": "A list of strings representing glyphs in the `legend`",
                    "type": "array",
                    "items": {
                        "type": "string"
                    },
                    "minItems": 1
                },
                "label": {
                    "description": "The text that will appear at the top left of the area",
                    "type": "string"
                },
                "width": {
                    "description": "By default, the pieces area will wrap once it reaches the width of the game board itself. This lets you set a fixed width. Expressed as number of pieces.",
                    "$ref": "#/$defs/positiveInteger"
                },
                "background": {
                    "description": "Optional. A colour you want to shade the background with. Helpful when dealing with borderless pieces or weird colours.",
                    "$ref": "#/$defs/colourstrings",
                    "default": "#fff"
                },
                "ownerMark": {
                    "description": "Optional. Places a coloured bar to the left of the area, used to indicate ownership.",
                    "anyOf": [
                        {"$ref": "#/$defs/positiveInteger"},
                        {"$ref": "#/$defs/colourstrings"}
                    ]
                }
            },
            "required": ["type", "pieces", "label"],
            "additionalProperties": false
        },
        "areaReserves": {
            "description": "This is a special area currently only used for the DVGC games and incorporates a `pieces`-style area into the game board itself. It is currently only designed for two-player use with 180 degree rotation. The area is clickable, as are the pieces within. You must tell the renderer which area belongs to which player.",
            "type": "object",
            "properties": {
                "type": {
                    "enum": ["reserves"]
                },
                "pieces": {
                    "description": "A list of strings representing glyphs in the `legend`",
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "side": {
                    "description": "What side of the board does this belong on",
                    "enum": ["N", "S"]
                },
                "background": {
                    "description": "Optional. A colour you want to shade the background with. Helpful when dealing with borderless pieces or weird colours.",
                    "anyOf": [
                        {"$ref": "#/$defs/positiveInteger"},
                        {"$ref": "#/$defs/colourstrings"}
                    ]
                },
                "ownerMark": {
                    "description": "Optional. Places a coloured bar to the left of the area, used to indicate ownership.",
                    "anyOf": [
                        {"$ref": "#/$defs/positiveInteger"},
                        {"$ref": "#/$defs/colourstrings"}
                    ]
                }
            },
            "required": ["type", "background", "pieces", "side"],
            "additionalProperties": false
        },
        "areaPolyomino": {
            "description": "Used by the `polyomino` renderer to display a selected piece and provide UI for manipulating it. Current maninpulations are rotating in 90-degree increments and flipping horizontally and vertically.",
            "type": "object",
            "properties": {
                "type": {
                    "enum": ["polyomino"]
                },
                "label": {
                    "type": "string"
                },
                "matrix": {
                    "$ref": "#/$defs/polymatrix"
                },
                "background": {
                    "description": "Optional. A colour you want to shade the background with. Helpful when dealing with borderless pieces or weird colours.",
                    "$ref": "#/$defs/colourstrings",
                    "default": "#fff"
                }
            },
            "required": ["type", "matrix", "label"],
            "additionalProperties": false
        },
        "areaHWStash": {
            "description": "The 'stash' definition for the homeworlds renderer. All colours must be specified. Empty strings represent empty stashes.",
            "type": "object",
            "properties": {
                "type": {
                    "enum": ["globalStash"]
                },
                "R": {
                    "$ref": "#/$defs/stashstrings"
                },
                "G": {
                    "$ref": "#/$defs/stashstrings"
                },
                "B": {
                    "$ref": "#/$defs/stashstrings"
                },
                "Y": {
                    "$ref": "#/$defs/stashstrings"
                }
            },
            "required": [
                "type",
                "R",
                "G",
                "B",
                "Y"
            ],
            "additionalProperties": false
        },
        "areaStackingExpanded": {
            "description": "Used by the `stacking-expanding` renderer to display the expanded contents of a cell.",
            "type": "object",
            "properties": {
                "type": {
                    "enum": ["expandedColumn"]
                },
                "cell": {
                    "description": "The coordinates of the cell being expanded (optional).",
                    "type": "string"
                },
                "stack": {
                    "description": "List of pieces (each must appear in the `legend`) to display alongside the board. The first piece in the array is the bottom of the stack.",
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                }
            },
            "required": ["type", "stack"],
            "additionalProperties": false
        },
        "areaVolcanoStash": {
            "description": "Used by the `stacking-expanding` renderer for displaying stashes of pyramids (e.g., captured pieces in a Volcano game).",
            "type": "object",
            "properties": {
                "type": {
                    "enum": ["localStash"]
                },
                "label": {
                    "type": "string"
                },
                "stash": {
                    "description": "This is an array of stacks of pieces (themselves an array).",
                    "type": "array",
                    "items": {
                        "description": "The stack of pieces is displayed from the bottom to the top, read left to right.",
                        "type": "array",
                        "items": {
                            "description": "The pieces to be placed. Must exist in the `legend`.",
                            "type": "string"
                        }
                    }
                }
            },
            "required": ["type", "label", "stash"],
            "additionalProperties": false
        },
        "buttonBarButton": {
            "type": "object",
            "properties": {
                "label": {
                    "description": "The label that will be visible on the rendered image.",
                    "type": "string",
                    "minLength": 1
                },
                "value": {
                    "description": "The value passed to the click handler as `_btn_X`, where `X` is the value here. If omitted, the label will be passed as is.",
                    "type": "string",
                    "pattern": "^\\S+$"
                },
                "attributes": {
                    "description": "Lets you pass attributes to the `<text>` tag for things like strikethrough and italics. See the SVG spec for a list of applicable attributes.",
                    "type": "array",
                    "minItems": 1,
                    "items": {
                        "type": "object",
                        "properties": {
                            "name": {
                                "type": "string"
                            },
                            "value": {
                                "type": "string"
                            }
                        },
                        "required": ["name", "value"],
                        "additionalProperties": false
                    }
                },
                "fill": {
                    "description": "Optional fill for this specific button.",
                    "$ref": "#/$defs/colourstrings",
                    "default": "#000"
                }
            },
            "required": ["label"],
            "additionalProperties": false
        },
        "areaButtonBar": {
            "description": "Used to create a button bar for clicking.",
            "type": "object",
            "properties": {
                "type": {
                    "enum": ["buttonBar"]
                },
                "buttons": {
                    "description": "The array of the buttons themselves, which will be presented in the order given.",
                    "type": "array",
                    "minItems": 1,
                    "items": {"$ref": "#/$defs/buttonBarButton"}
                },
                "position": {
                    "description": "Where you want the bar to appear relative to the board.",
                    "enum": ["left", "right"],
                    "default": "right"
                },
                "height": {
                    "description": "The height of each button as a percentage of the cell size.",
                    "type": "number",
                    "minimum": 0,
                    "default": 1
                },
                "minWidth": {
                    "description": "If you want the buttons to have a minimum width, regardless of the values, provide it here as a percentage of the cell size. Otherwise all the buttons will have the width of the widest label.",
                    "type": "number",
                    "minimum": 0
                },
                "buffer": {
                    "description": "The spacing you want between each button, expressed as a percentage of the height.",
                    "type": "number",
                    "minimum": 0,
                    "default": 0
                },
                "colour": {
                    "description": "The colour of the button border and text.",
                    "$ref": "#/$defs/colourstrings",
                    "default": "#000"
                }
            },
            "required": ["type", "buttons"],
            "additionalProperties": false
        },
        "areaScrollBar": {
            "description": "Used to create a clickable vertical scroll bar used for hiding/showing layers of pieces.",
            "type": "object",
            "properties": {
                "type": {
                    "enum": ["scrollBar"]
                },
                "min": {
                    "description": "The lowest value of the bar (usually 0).",
                    "type": "integer",
                    "default": 0
                },
                "max": {
                    "description": "The highest value of the bar.",
                    "type": "integer"
                },
                "current": {
                    "description": "The current value of the bar.",
                    "type": "integer",
                    "default": 0
                },
                "labels": {
                    "description": "Defines the text labels for each of the clickable elements.",
                    "type": "object",
                    "properties": {
                        "upOne": {
                            "type": "string",
                            "default": "+"
                        },
                        "upAll": {
                            "type": "string",
                            "default": "++"
                        },
                        "downOne": {
                            "type": "string",
                            "default": "\u2212"
                        },
                        "downAll": {
                            "type": "string",
                            "default": "\u2212\u2212"
                        },
                        "bar": {
                            "type": "string",
                            "default": "Hide/show layers"
                        }
                    },
                    "additionalProperties": false
                },
                "position": {
                    "description": "Where you want the bar to appear relative to the board.",
                    "enum": ["left", "right"],
                    "default": "right"
                },
                "width": {
                    "description": "The width of each scroll bar segment as a percentage of the cell size.",
                    "type": "number",
                    "minimum": 0,
                    "default": 0.25
                },
                "height": {
                    "description": "The height of each scroll bar segment as a percentage of the cell size.",
                    "type": "number",
                    "minimum": 0,
                    "default": 0.75
                },
                "lineWidth": {
                    "description": "By default, each segment is signalled by lines that extend beyond the width of the bar itself. This defines the extra width of that line, as a percentage of the total width.",
                    "type": "number",
                    "minimum": 0,
                    "maximum": 1,
                    "default": 0.5
                },
                "colours": {
                    "description": "Defines the various colour settings.",
                    "type": "object",
                    "properties": {
                        "background": {
                            "description": "Defaults to fully transparent background",
                            "$ref": "#/$defs/colourstrings"
                        },
                        "fill": {
                            "$ref": "#/$defs/colourstrings",
                            "default": "#000"
                        },
                        "strokes": {
                            "description": "Lines and text",
                            "$ref": "#/$defs/colourstrings",
                            "default": "#000"
                        }
                    },
                    "additionalProperties": false
                }
            },
            "required": ["type", "max"],
            "additionalProperties": false
        },
        "areaKey": {
            "description": "A list of pieces in the `legend` that players need identifiers for. Usually needed for games with many colours or just indicating who controls what.",
            "type": "object",
            "properties": {
                "type": {
                    "enum": ["key"]
                },
                "list": {
                    "description": "The list of piece ids (must exist in the `legend`) and a short string the user should associate with it. They will be listed in the order provided.",
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "piece": {
                                "type": "string"
                            },
                            "name": {
                                "type": "string"
                            },
                            "value": {
                                "description": "If a click handler is attached, this is the value that will be given in the \"piece\" parameter. Otherwise it will pass the name.",
                                "type": "string"
                            }
                        },
                        "required": ["piece", "name"],
                        "additionalProperties": false
                    }
                },
                "height": {
                    "description": "The height of each entry as a percentage of cell size.",
                    "type": "number",
                    "minimum": 0,
                    "default": 0.333
                },
                "buffer": {
                    "description": "The spacing you want between each entry, expressed as a percentage of the height.",
                    "type": "number",
                    "minimum": 0,
                    "default": 0.1
                },
                "position": {
                    "description": "Where you would prefer the legend be placed relative to the game board. Specific renderers may override your preference.",
                    "enum": ["left", "right"],
                    "default": "right"
                },
                "clickable": {
                    "description": "By default, `key` entries have a click handler attached. Set this to `false` to disable that.",
                    "type": "boolean",
                    "default": true
                }
            },
            "required": ["list"],
            "additionalProperties": false
        },
        "markerDots": {
            "type": "object",
            "properties": {
                "type": {
                    "description": "A way of placing small marker dots at certain points of the board.",
                    "enum": ["dots"]
                },
                "points": {
                    "description": "Like with `annotations`, the renderer knows nothing about a game's notation. You must provide instead the column and row numbers, which are zero-based: 0,0 is the top row, top column.",
                    "type": "array",
                    "items": {"$ref": "#/$defs/rowCol"},
                    "minItems": 1
                },
                "size": {
                    "description": "The size of the diameter of the dot as a fraction of cellsize.",
                    "type": "number",
                    "default": 0.2
                },
                "colour": {
                    "description": "The colour of the shaded area. Can be either a number (which will be interpreted as a built-in player colour) or a hexadecimal colour string.",
                    "anyOf": [
                        {"$ref": "#/$defs/positiveInteger"},
                        {"$ref": "#/$defs/colourstrings"}
                    ],
                    "default": "#000"
                },
                "opacity": {
                    "description": "1 is fully opaque. 0 is fully transparent.",
                    "type": "number",
                    "minimum": 0,
                    "maximum": 1,
                    "default": 1
                }
            },
            "required": ["type", "points"],
            "additionalProperties": false
        },
        "markerShading": {
            "type": "object",
            "properties": {
                "type": {
                    "description": "This is for shading spaces or areas on the board.",
                    "enum": ["shading"]
                },
                "belowGrid": {
                    "description": "If true, the shading will be done below the grid lines.",
                    "type": "boolean"
                },
                "points": {
                    "description": "It expects at least three points, forming an auto-closed polygon. Board styles where a point is the center of a space (like the `squares` board style) instead point to the top-left corner of the space. Some experimentation may be required to enclose the area you want.",
                    "type": "array",
                    "items": {"$ref": "#/$defs/rowCol"},
                    "minItems": 3
                },
                "colour": {
                    "description": "The colour of the shaded area. Can be either a number (which will be interpreted as a built-in player colour) or a hexadecimal colour string.",
                    "anyOf": [
                        {"$ref": "#/$defs/positiveInteger"},
                        {"$ref": "#/$defs/colourstrings"}
                    ],
                    "default": "#000"
                },
                "opacity": {
                    "description": "1 is fully opaque. 0 is fully transparent.",
                    "type": "number",
                    "minimum": 0,
                    "maximum": 1,
                    "default": 0.25
                }
            },
            "required": ["type", "points"],
            "additionalProperties": false
        },
        "markerFlood": {
            "type": "object",
            "properties": {
                "type": {
                    "description": "Only usable by board styles composed of polygons. Distinct from shading, this will simply fill the specified cells with a colour.",
                    "enum": ["flood"]
                },
                "belowGrid": {
                    "description": "If true, places the flood fill before the gridlines. If a filled `halo` marker is present, that must appear before the flood fills.",
                    "type": "boolean",
                    "default": true
                },
                "points": {
                    "description": "One or more grid coordinates of spaces to fill.",
                    "type": "array",
                    "items": {"$ref": "#/$defs/rowCol"},
                    "minItems": 1
                },
                "colour": {
                    "description": "The colour of the shaded area. Can be either a number (which will be interpreted as a built-in player colour) or a hexadecimal colour string.",
                    "anyOf": [
                        {"$ref": "#/$defs/positiveInteger"},
                        {"$ref": "#/$defs/colourstrings"},
                        {"$ref": "#/$defs/gradient"}
                    ],
                    "default": "#000"
                },
                "opacity": {
                    "description": "1 is fully opaque. 0 is fully transparent.",
                    "type": "number",
                    "minimum": 0,
                    "maximum": 1,
                    "default": 0.25
                },
                "pulse": {
                    "description": "Makes the the fill pulse opacity over the defined interval in milliseconds",
                    "type": "integer",
                    "minimum": 0
                }
            },
            "required": ["type", "points"],
            "additionalProperties": false
        },
        "markerOutline": {
            "type": "object",
            "properties": {
                "type": {
                    "description": "Only usable by boards constructed out of premade shapes (e.g., `hex-of-hex`, `sowing`). Uses the given colour as the outline of the given cell shape.",
                    "enum": ["outline"]
                },
                "points": {
                    "description": "One or more grid coordinates of spaces to fill.",
                    "type": "array",
                    "items": {"$ref": "#/$defs/rowCol"},
                    "minItems": 1
                },
                "colour": {
                    "description": "The colour of the shaded area. Can be either a number (which will be interpreted as a built-in player colour) or a hexadecimal colour string.",
                    "anyOf": [
                        {"$ref": "#/$defs/positiveInteger"},
                        {"$ref": "#/$defs/colourstrings"}
                    ],
                    "default": "#000"
                },
                "opacity": {
                    "description": "1 is fully opaque. 0 is fully transparent.",
                    "type": "number",
                    "minimum": 0,
                    "maximum": 1,
                    "default": 0.25
                }
            },
            "required": ["type", "points", "colour"],
            "additionalProperties": false
        },
        "markerHalo": {
            "type": "object",
            "properties": {
                "type": {
                    "description": "Only used for `circular-*` and `conical-hex*` boards. Draws an encompassing circle around the board, usually used to indicate ownership of segments",
                    "enum": ["halo"]
                },
                "segments": {
                    "description": "If only one segment is given, then a single circle will be drawn. Otherwise, the circle will be divided into equal chunks and drawn in the order specified, proceeding clockwise. The first segment will align with the `circular-start` given in `board` (`0` by default).",
                    "type": "array",
                    "minItems": 1,
                    "items": {
                        "type": "object",
                        "properties": {
                            "colour": {
                                "description": "The colour of the line. Can be either a number (which will be interpreted as a built-in player colour) or a hexadecimal colour string.",
                                "anyOf": [
                                    {"$ref": "#/$defs/positiveInteger"},
                                    {"$ref": "#/$defs/colourstrings"}
                                ]
                            },
                            "opacity": {
                                "description": "1 is fully opaque. 0 is fully transparent.",
                                "type": "number",
                                "minimum": 0,
                                "maximum": 1,
                                "default": 1
                            },
                            "style": {
                                "enum": [
                                    "solid",
                                    "dashed"
                                ],
                                "default": "solid"
                            }
                        },
                        "required": ["colour"],
                        "additionalProperties": false
                    }
                },
                "width": {
                    "description": "Stroke width of the line",
                    "type": "number",
                    "minimum": 0,
                    "default": 5
                },
                "offset": {
                    "description": "By default, the halo aligns with the board sections (see `circular-start`). Sometimes you want to offset them. Provide the offset in absolute degrees, with positive numbers rotating clockwise.",
                    "type": "number",
                    "default": 0
                },
                "fill": {
                    "description": "Fill is drawn before grid lines, segments are drawn after grid lines.",
                    "anyOf": [
                        {"$ref": "#/$defs/positiveInteger"},
                        {"$ref": "#/$defs/colourstrings"}
                    ]
                }
            },
            "required": ["type", "segments"],
            "additionalProperties": false
        },
        "markerLine": {
            "type": "object",
            "properties": {
                "type": {
                    "description": "A way of drawing arbitrary lines on the board. By default, respects the stroke width, colour, and opacity of the larger board.",
                    "enum": ["line"]
                },
                "points": {
                    "description": "Expects exactly two points. Board styles where a point is the center of a space (like the `squares` board style) instead point to the top-left corner of the space. Some experimentation may be required.",
                    "type": "array",
                    "items": {"$ref": "#/$defs/rowCol"},
                    "minItems": 2,
                    "maxItems": 2
                },
                "colour": {
                    "description": "The colour of the line. Can be either a number (which will be interpreted as a built-in player colour) or a hexadecimal colour string.",
                    "anyOf": [
                        {"$ref": "#/$defs/positiveInteger"},
                        {"$ref": "#/$defs/colourstrings"}
                    ],
                    "default": "#000"
                },
                "opacity": {
                    "description": "1 is fully opaque. 0 is fully transparent.",
                    "type": "number",
                    "minimum": 0,
                    "maximum": 1,
                    "default": 0.5
                },
                "width": {
                    "description": "Stroke width of the line",
                    "type": "number",
                    "minimum": 0,
                    "default": 1
                },
                "style": {
                    "enum": [
                        "solid",
                        "dashed"
                    ],
                    "default": "solid"
                },
                "centered": {
                    "description": "By default, on boards like `squares*`, lines anchor to the top-left corner of the cell. If `centered` is true, it will instead anchor to the centre point of the cell.",
                    "type": "boolean",
                    "default": false
                },
                "clickable": {
                    "description": "Adds a click handler to the line. This can get in the way of regular clicks, depending on how your board is configured.",
                    "type": "boolean",
                    "default": "false"
                },
                "belowGrid": {
                    "description": "If true, the labels will be drawn below the grid lines.",
                    "type": "boolean"
                },
                "shorten": {
                    "description": "Let's you trim the ends of a line. Expressed as a percentage of total length.",
                    "type": "number",
                    "minimum": 0,
                    "exclusiveMaximum": 1,
                    "default": 0
                }
            },
            "required": ["type", "points"],
            "additionalProperties": false
        },
        "markerLabel": {
            "type": "object",
            "properties": {
                "type": {
                    "description": "A ham-fisted way of getting arbitrary labels on a board or series of boards (e.g., Wizard's Garden). Experimentation will definitely be needed to accomplish your goal.",
                    "enum": ["label"]
                },
                "belowGrid": {
                    "description": "If true, the labels will be drawn below the grid lines.",
                    "type": "boolean"
                },
                "label": {
                    "description": "The string itself you want to display.",
                    "type": "string"
                },
                "points": {
                    "description": "Expects exactly two points. This defines a line along which the text will flow and be centred along, as best as we can.",
                    "type": "array",
                    "items": {"$ref": "#/$defs/rowCol"},
                    "minItems": 2,
                    "maxItems": 2
                },
                "nudge": {
                    "description": "You almost never want a label *on* the board. Nudge lets you use board coordinates to get started and then move that line by a multiple of the 'cellspacing' (i.e., the base unit, the width of a square in a square grid). The nudge is applied to both points.",
                    "type": "object",
                    "properties": {
                        "dx": {
                            "type": "number"
                        },
                        "dy": {
                            "type": "number"
                        }
                    },
                    "required": ["dx", "dy"],
                    "additionalProperties": false
                },
                "colour": {
                    "description": "The colour of the shaded area. Can be either a number (which will be interpreted as a built-in player colour) or a hexadecimal colour string.",
                    "anyOf": [
                        {"$ref": "#/$defs/positiveInteger"},
                        {"$ref": "#/$defs/colourstrings"}
                    ],
                    "default": "#000"
                },
                "size": {
                    "description": "Font size in absolute pixels",
                    "type": "number",
                    "default": 17
                },
                "font": {
                    "description": "Font style, e.g. 'font: Stencil; font-weight: Bold'",
                    "type": "string",
                    "default": ""
                }
            },
            "required": ["type", "label", "points"],
            "additionalProperties": false
        },
        "markerEdge": {
            "type": "object",
            "properties": {
                "type": {
                    "description": "This will highlight one edge of the board, indicated by compass direction. It relies on the properties`strokeWeight` and `strokeOpacity`, if given. It does not work on the `hex-odd*`, `hex-even*`, `hex-of-cir` or `hex-of-hex` boards.",
                    "enum": ["edge"]
                },
                "edge": {
                    "description": "An invalid edge designator (NE on a square map, for example) will just be ignored.",
                    "enum": ["N", "NE", "E", "SE", "S", "SW", "W", "NW"]
                },
                "colour": {
                    "description": "The colour of the shaded area. Can be either a number (which will be interpreted as a built-in player colour) or a hexadecimal colour string.",
                    "anyOf": [
                        {"$ref": "#/$defs/positiveInteger"},
                        {"$ref": "#/$defs/colourstrings"}
                    ]
                },
                "opacity": {
                    "type": "number",
                    "minimum": 0,
                    "maximum": 1,
                    "default": 1
                }
            },
            "required": ["type", "edge", "colour"],
            "additionalProperties": false
        },
        "markerFenceData": {
            "type": "object",
            "properties": {
                "cell": {"$ref": "#/$defs/rowCol"},
                "side": {
                    "enum": ["N", "NE", "E", "SE", "S", "SW", "W", "NW"]
                },
                "colour": {
                    "description": "The colour of the fence. Can be either a number (which will be interpreted as a built-in player colour) or a hexadecimal colour string.",
                    "anyOf": [
                        {"$ref": "#/$defs/positiveInteger"},
                        {"$ref": "#/$defs/colourstrings"}
                    ],
                    "default": "#000"
                },
                "width": {
                    "description": "Expressed as a multiple of the base stroke width",
                    "type": "number",
                    "default": 6
                },
                "dashed": {
                    "description": "A valid `dasharray` appropriate for the game's display.",
                    "type": "array",
                    "items": {
                        "type": "number"
                    }
                }
            },
            "required": ["cell", "side"],
            "additionalProperties": false
        },
        "markerFence": {
            "type": "object",
            "properties": {
                "type": {
                    "description": "Only works for the `squares*` and rect-of-hex board styles. Draws a thick line between two adjacent cells. It doesn't check adjacency, but the results will not be what you expect otherwise.",
                    "enum": ["fence"]
                },
                "cell": {"$ref": "#/$defs/rowCol"},
                "side": {
                    "enum": ["N", "NE", "E", "SE", "S", "SW", "W", "NW"]
                },
                "colour": {
                    "description": "The colour of the fence. Can be either a number (which will be interpreted as a built-in player colour) or a hexadecimal colour string.",
                    "anyOf": [
                        {"$ref": "#/$defs/positiveInteger"},
                        {"$ref": "#/$defs/colourstrings"}
                    ],
                    "default": "#000"
                },
                "width": {
                    "description": "Expressed as a multiple of the base stroke width",
                    "type": "number",
                    "default": 6
                },
                "dashed": {
                    "description": "A valid `dasharray` appropriate for the game's display.",
                    "type": "array",
                    "items": {
                        "type": "number"
                    }
                }
            },
            "required": ["type", "cell", "side"],
            "additionalProperties": false
        },
        "markerFences": {
            "description": "Just a container marker for multiple fences",
            "type": "object",
            "properties": {
                "type": {
                    "enum": ["fences"]
                },
                "sides": {
                    "type": "array",
                    "minItems": 1,
                    "items": {"$ref": "#/$defs/markerFenceData"}
                }
            },
            "required": ["type", "sides"],
            "additionalProperties": false
        },
        "markerGlyph": {
            "type": "object",
            "properties": {
                "type": {
                    "description": "A way of incorporating a glyph from the legend into the board itself. Currently only works in the `default` and `stacking-offset` renderer.",
                    "enum": ["glyph"]
                },
                "belowGrid": {
                    "description": "If true, the glyph will be drawn below the grid lines.",
                    "type": "boolean"
                },
                "glyph": {
                    "description": "The name of the glyph in the `legend`.",
                    "type": "string"
                },
                "points": {
                    "description": "Like with `annotations`, the renderer knows nothing about a game's notation. You must provide instead the column and row numbers, which are zero-based: 0,0 is the top row, top column.",
                    "type": "array",
                    "items": {"$ref": "#/$defs/rowCol"},
                    "minItems": 1
                }
            },
            "required": ["type", "glyph", "points"],
            "additionalProperties": false
        },
        "markerFreespaceLabel": {
            "type": "object",
            "properties": {
                "type": {
                    "description": "A ham-fisted way of getting arbitrary labels on a board or series of boards (e.g., Wizard's Garden). Experimentation will definitely be needed to accomplish your goal.",
                    "enum": ["label"]
                },
                "label": {
                    "description": "The string itself you want to display.",
                    "type": "string"
                },
                "points": {
                    "description": "Expects exactly two points. This defines a line along which the text will flow and be centred along, as best as we can.",
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "x": {
                                "type": "number"
                            },
                            "y": {
                                "type": "number"
                            }
                        },
                        "required": ["x", "y"],
                        "additionalProperties": false
                    },
                    "minItems": 2,
                    "maxItems": 2
                },
                "colour": {
                    "description": "The colour of the shaded area. Can be either a number (which will be interpreted as a built-in player colour) or a hexadecimal colour string.",
                    "anyOf": [
                        {"$ref": "#/$defs/positiveInteger"},
                        {"$ref": "#/$defs/colourstrings"}
                    ],
                    "default": "#000"
                },
                "size": {
                    "description": "Font size in absolute pixels",
                    "type": "number",
                    "default": 17
                }
            },
            "required": ["type", "label", "points"],
            "additionalProperties": false
        },
        "markerFreespaceGlyph": {
            "type": "object",
            "properties": {
                "type": {
                    "description": "A way of incorporating a glyph from the legend into the board itself.",
                    "enum": ["glyph"]
                },
                "glyph": {
                    "description": "The name of the glyph in the `legend`.",
                    "type": "string"
                },
                "orientation": {
                    "type": "number"
                },
                "points": {
                    "description": "Provide absolute x,y coordinates.",
                    "type": "array",
                    "items": {
                        "type": "object",
                        "properties": {
                            "x": {
                                "type": "number"
                            },
                            "y": {
                                "type": "number"
                            }
                        },
                        "required": ["x", "y"],
                        "additionalProperties": false
                    },
                    "minItems": 1
                }
            },
            "required": ["type", "glyph", "points"],
            "additionalProperties": false
        },
        "markerPath": {
            "type": "object",
            "description": "A simple SVG path with stroke and fill attributes.",
            "properties": {
                "type": {
                    "enum": ["path"]
                },
                "path": {
                    "type": "string"
                },
                "fill": {
                    "anyOf": [
                        {"$ref": "#/$defs/positiveInteger"},
                        {"$ref": "#/$defs/colourstrings"}
                    ],
                    "default": "#fff"
                },
                "fillOpacity": {
                    "type": "number",
                    "minimum": 0,
                    "maximum": 1,
                    "default": 1
                },
                "stroke": {
                    "anyOf": [
                        {"$ref": "#/$defs/positiveInteger"},
                        {"$ref": "#/$defs/colourstrings"}
                    ],
                    "default": "#000"
                },
                "strokeWidth": {
                    "type": "number",
                    "minimum": 0.1,
                    "default": 1
                },
                "strokeOpacity": {
                    "type": "number",
                    "minimum": 0,
                    "maximum": 1,
                    "default": 1
                },
                "dashed": {
                    "description": "A valid `dasharray` appropriate for the game's display.",
                    "type": "array",
                    "items": {
                        "type": "number"
                    }
                }
            },
            "required": ["type", "path"],
            "additionalProperties": false
        },
        "piecesHomeworlds": {
            "description": "The required schema for the `homeworlds` renderer. It supports 4 players and colours. The `board` property describes the systems. This property describes the pieces in each system. The order the systems are declared must be the same as how they are declared in the `board` property. That means the arrays must also be the same length. Empty arrays are allowed because sometimes you need to display an empty home system in the middle of a turn.",
            "type": "array",
            "items": {
                "description": "The actual array of pieces in the given system.",
                "type": "array",
                "minItems": 0,
                "maxItems": 24,
                "items": {
                    "type": "string",
                    "pattern": "^p[RGBY][123][NESW]$"
                }
            }
        },
        "boardBasic": {
            "description": "One of the preset boards.",
            "type": "object",
            "properties": {
                "style": {"$ref": "#/$defs/boardStyles"},
                "rotate": {
                    "description": "Allows the game itself to rotate the base board. This is added to whatever user-provided rotation is requested. Rotation is applied after the entire board is rendered, and then key elements are reoriented vertically.",
                    "type": "number",
                    "minimum": -360,
                    "maximum": 360
                },
                "labelColour": {
                    "description": "The colour for the board labels. Defaults to the colour passed into the context (default black).",
                    "$ref": "#/$defs/colourstrings",
                    "default": "#000"
                },
                "strokeColour": {
                    "description": "The colour for lines drawn to construct the board.",
                    "$ref": "#/$defs/colourstrings",
                    "default": "#000"
                },
                "strokeWeight": {
                    "description": "The base stroke weight of lines drawn to construct the board.",
                    "$ref": "#/$defs/positiveNumber",
                    "default": 1
                },
                "labelOpacity": {
                    "description": "The opacity of lines drawn to construct the board.",
                    "type": "number",
                    "minimum": 0,
                    "maximum": 1,
                    "default": 1
                },
                "strokeOpacity": {
                    "description": "The opacity of lines drawn to construct the board.",
                    "type": "number",
                    "minimum": 0,
                    "maximum": 1,
                    "default": 1
                },
                "backFill": {
                    "description": "Used to add a solid block of colour behind the entire image. This should usually be left to the client, but sometimes you want the option.",
                    "type": "object",
                    "properties": {
                        "type": {
                            "description": "`full` just draws a rectangle behind the entire rendered field, including any labels. `board` only works for boards created from polygons and attempts to only draw the fill behind the board itself.",
                            "enum": ["full", "board"],
                            "default": "full"
                        },
                        "colour": {
                            "$ref": "#/$defs/colourstrings"
                        },
                        "opacity": {
                            "type": "number",
                            "minimum": 0,
                            "maximum": 1,
                            "default": 1
                        }
                    },
                    "required": ["colour"],
                    "additionalProperties": false
                },
                "blocked": {
                    "description": "On `squares*` boards, blacks out the specified cells and disables clicking. For hex grids, the hex simply isn't drawn. Like with `annotations`, the renderer knows nothing about a game's notation. You must provide instead the column and row numbers, which are zero-based: 0,0 is the top row, top column.",
                    "type": "array",
                    "items": {"$ref": "#/$defs/rowCol"},
                    "minItems": 1
                },
                "minWidth": {
                    "description": "Only meaningful for the 'hex_of_*' styles. Determines the minimum width at the top and bottom of the board.",
                    "$ref": "#/$defs/positiveInteger"
                },
                "maxWidth": {
                    "description": "Only meaningful for the 'hex_as_*' styles. Determines the maximum width at the centre of the board.",
                    "$ref": "#/$defs/positiveInteger"
                },
                "half": {
                    "description": "Only meaningful for the `hex-of-*` boards. Tells the system to only render the top or bottom half of the hex, letting you build things like triangles and some rhomboids. Mutually exclusive with `alternatingSymmetry`.",
                    "enum": ["top", "bottom"]
                },
                "width": {
                    "description": "Required for the `squares*`, `vertex`, and `go` styles. For `circular-*` boards, specifies the number of slices.",
                    "$ref": "#/$defs/positiveInteger"
                },
                "height": {
                    "description": "Required for the `squares*`, `vertex`, and `go` styles. For `circular-*` boards, specifies the number of rings.",
                    "$ref": "#/$defs/positiveInteger"
                },
                "showEndPits": {
                    "description": "Only applies to the `sowing` board style. Determines whether to include full-height end pits on the board.",
                    "type": "boolean",
                    "default": true
                },
                "squarePits": {
                    "description": "Only applies to the `sowing` board style. By default, pits have rounded corners. In games like Bao, specific spaces are distinct. This property tells the renderer the row and column of these spaces.",
                    "type": "array",
                    "items": {"$ref": "#/$defs/rowCol"},
                    "minItems": 1
                },
                "clickDeltaX": {
                    "description": "Only meaningful for the `squares*` and `vertex` boards. Defines the size (in board square units) of the clickable area around left and right sides of the board. So an invisisble 'bearing off' area.",
                    "$ref": "#/$defs/positiveInteger"
                },
                "clickDeltaY": {
                    "description": "Only meaningful for the `squares*` and `vertex` boards. Defines the size (in board square units) of the clickable area above and below the board. So an invisisble 'bearing off' area.",
                    "$ref": "#/$defs/positiveInteger"
                },
                "startLight": {
                    "description": "Only meaningful for the `squares-checkered` boards. Determines whether the first row start with a light or dark square.",
                    "type": "boolean"
                },
                "alternatingSymmetry": {
                    "description": "Only meaningful for `hex-of-*` boards and generates configurations where the sides alternate between two sizes. Mutually exclusive with `half`.",
                    "type": "boolean"
                },
                "columnLabels": {
                    "description": "An optional array of strings to override the default column labeling.",
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "rowLabels": {
                    "description": "An optional array of strings to override the default row labeling.",
                    "type": "array",
                    "items": {
                        "type": "string"
                    }
                },
                "labelStyle": {
                    "description": "Currently only applies to hex fields",
                    "enum": ["internal", "external"],
                    "default": "internal"
                },
                "skipLabels": {
                    "description": "A ham-fisted way to omit row and column labels you don't want displayed for some reason. Currently only used by the `triangles-stacked` renderer for certain board sizes.",
                    "type": "array",
                    "minItems": 1,
                    "items": {
                        "description": "For now, simply matches the string against the label.",
                        "type": "string"
                    }
                },
                "tileWidth": {
                    "description": "Only meaningful for the `squares` and `vertex` boards. Defines sections X cells wide as tiles. If `tileSpacing` is given, these tiles will be broken apart from each other. Otherwise, a heavier line is drawn to delineate.",
                    "$ref": "#/$defs/positiveInteger"
                },
                "tileHeight": {
                    "description": "Only meaningful for the `squares` and `vertex` boards. Defines sections X cells high as tiles. If `tileSpacing` is given, these tiles will be broken apart from each other. Otherwise, a heavier line is drawn to delineate.",
                    "$ref": "#/$defs/positiveInteger"
                },
                "tileSpacing": {
                    "description": "If given, instead of drawing heavier lines to create tiles, it insteads breaks the boards into pieces and spreads them apart by this amount. This number represents the percent of one cell size. So a value of `1` is one cell size of spacing; `0.5` is half, `2` is double.",
                    "type": "number",
                    "minimum": 0,
                    "default": 0
                },
                "stackMax": {
                    "description": "Only valid for the `stacking-tiles` renderer. Specifies the maximum number of tiles allowed in a cell.",
                    "type": "integer",
                    "minimum": 1,
                    "default": 8
                },
                "stackOffset": {
                    "description": "Only valid for the `stacking-offset` renderer. A number between 0 and 1 representing the percentage of a cell's space that should be used to offset each piece in the stack. A value of 1 will lead to no overlap. A value of 0 will stack all the pieces directly on top of each other.",
                    "type": "number",
                    "minimum": 0,
                    "maximum": 1,
                    "default": 0.13
                },
                "circular-start": {
                    "description": "By default, circular boards start with a vertical line drawn from the centre straight \"north\". This lets you choose a different starting degree. In this plane, 0 degrees is towards the top of the screen and increases clockwise.",
                    "type": "number",
                    "minimum": -360,
                    "maximum": 360,
                    "default": 0
                },
                "cairoStart": {
                    "description": "For the `cairo-collinear` board, the top-left pair of pentagons can either be oriented horizontally or vertically.",
                    "type": "string",
                    "enum": ["H","V"],
                    "default": "H"
                },
                "sdStart": {
                    "description": "For the `squares-diamonds` board, the board edge can start with diamonds or squares (actually octagons). By default, the edges start with squares, but you can also start them with diamonds.",
                    "type": "string",
                    "enum": ["S","D"],
                    "default": "S"
                },
                "buffer": {
                    "description": "Adds a visible area around the outside of the board intended to be used with a click handler for bearing off pieces or other such interactions. Only applied to the `squares*`, `vertex*` and `go` boards. Uses the `strokeWeight/Colour/Opacity` options for the border, and can include an optional fill. The opacity and colour will also be applied to the fill.",
                    "type": "object",
                    "properties": {
                        "width": {
                            "description": "The width of the zone expressed as a percentage of the cell size. If zero, the zone is omitted.",
                            "type": "number",
                            "minimum": 0,
                            "maximum": 0.9
                        },
                        "pattern": {
                            "description": "The name of one of the built-in patterns for fill.",
                            "type": "string"
                        },
                        "show": {
                            "description": "Choose which of the four sides you want displayed. By default, it's all four.",
                            "type": "array",
                            "items": {
                                "enum": ["N", "E", "S", "W"]
                            },
                            "default": ["N", "E", "S", "W"]
                        }
                    },
                    "required": ["width"],
                    "additionalProperties": false
                },
                "heightmap": {
                    "description": "Only meaningful in the `isometric` renderer where it gives the heights of the various cells of the board. The two-dimensional array needs to map to the chosen playing field. The heights can be arbitrary, and the glyphs are generated on the fly. The glyphs in the contact sheet are for playing pieces.",
                    "type": "array",
                    "minItems": 1,
                    "items": {
                        "type": "array",
                        "minItems": 1,
                        "items": {
                            "type": "number"
                        }
                    }
                },
                "markers": {
                    "description": "Sometimes a board needs shaded areas, lines showing ownership of board edges, things like that. This is how those are indicated. Not all features are available for all board styles.",
                    "type": "array",
                    "items": {
                        "anyOf": [
                            {"$ref": "#/$defs/markerDots"},
                            {"$ref": "#/$defs/markerShading"},
                            {"$ref": "#/$defs/markerFlood"},
                            {"$ref": "#/$defs/markerOutline"},
                            {"$ref": "#/$defs/markerHalo"},
                            {"$ref": "#/$defs/markerLine"},
                            {"$ref": "#/$defs/markerLabel"},
                            {"$ref": "#/$defs/markerEdge"},
                            {"$ref": "#/$defs/markerFence"},
                            {"$ref": "#/$defs/markerFences"},
                            {"$ref": "#/$defs/markerGlyph"}
                        ]
                    }
                }
            },
            "required": ["style"],
            "additionalProperties": false
        },
        "boardHomeworlds": {
            "description": "The required schema for the `homeworlds` renderer. It supports 4 players and colours. The `board` property describes the systems. The `pieces` property describes the pieces.",
            "type": "array",
            "items": {
                "type": "object",
                "properties": {
                    "name": {
                        "description": "The name of the system. For simplicity, no whitespace, no weird characters, and 125 characters in length.",
                        "type": "string",
                        "minLength": 1,
                        "maxLength": 25,
                        "pattern": "^[A-Za-z0-9][A-Za-z0-9_-]*$"
                    },
                    "seat": {
                        "description": "If this is a home system, give the compass direction representing the player's seat. Omit property in shared systems.",
                        "enum": [
                            "N",
                            "E",
                            "S",
                            "W"
                        ]
                    },
                    "stars": {
                        "description": "Describes the system's stars. (For reasons, the schema does not require 1 or 2 stars, but in practice anything other this will give undefined results.)",
                        "type": "array",
                        "items": {
                            "type": "string",
                            "pattern": "^[RGBY][123]$"
                        }
                    }
                },
                "required": [
                    "name",
                    "stars"
                ],
                "additionalProperties": false
            }
        },
        "boardEntropy": {
            "description": "The board schema for the `entropy` renderer",
            "type": "object",
            "properties": {
                "style": {
                    "enum": ["entropy"]
                },
                "boardOne": {
                    "description": "Describes the left-hand or top board",
                    "type": "object",
                    "properties": {
                        "label": {
                            "type": "string",
                            "default": "Player 1: Order"
                        },
                        "occluded": {
                            "description": "Used as an aid to the player by occluding one of the boards",
                            "type": "boolean",
                            "default": false
                        }
                    },
                    "additionalProperties": false
                },
                "boardTwo": {
                    "description": "Describes the right-hand or bottom board",
                    "type": "object",
                    "properties": {
                        "label": {
                            "type": "string",
                            "default": "Player 2: Order"
                        },
                        "occluded": {
                            "description": "Used as an aid to the player by occluding one of the boards",
                            "type": "boolean",
                            "default": false
                        }
                    },
                    "additionalProperties": false
                },
                "orientation": {
                    "description": "Whether the two boards should be arranged horizontally or vertically",
                    "enum": ["horizontal", "vertical"],
                    "default": "horizontal"
                },
                "strokeWeight": {
                    "description": "The base stroke weight of lines drawn to construct the board.",
                    "$ref": "#/$defs/positiveNumber",
                    "default": 1
                },
                "strokeColour": {
                    "description": "The colour for lines drawn to construct the board, includes the labels.",
                    "$ref": "#/$defs/colourstrings",
                    "default": "#000"
                },
                "strokeOpacity": {
                    "description": "The opacity of lines drawn to construct the board, includes the labels.",
                    "type": "number",
                    "minimum": 0,
                    "maximum": 1,
                    "default": 1
                }
            },
            "required": ["style"],
            "additionalProperties": false
        },
        "boardFreespace": {
            "description": "Board schema for `freespace` boards",
            "type": "object",
            "properties": {
                "width": {
                    "description": "Width in pixels of the visible field. The total SVG size will likely be larger, especially if you include areas or other features.",
                    "type": "number"
                },
                "height": {
                    "description": "Width in pixels of the visible field. The total SVG size will likely be larger, especially if you include areas or other features.",
                    "type": "number"
                },
                "backFill": {
                    "description": "Used to add a solid block of colour behind the entire image. This should usually be left to the client, but sometimes you want the option.",
                    "type": "object",
                    "properties": {
                        "type": {
                            "description": "`full` just draws a rectangle behind the entire rendered field, including any labels. `board` only works for boards created from polygons and attempts to only draw the fill behind the board itself.",
                            "enum": ["full", "board"],
                            "default": "full"
                        },
                        "colour": {
                            "$ref": "#/$defs/colourstrings"
                        },
                        "opacity": {
                            "type": "number",
                            "minimum": 0,
                            "maximum": 1,
                            "default": 1
                        }
                    },
                    "required": ["colour"],
                    "additionalProperties": false
                },
                "origin": {
                    "description": "In most cases, you'll want the top-left corner of the field to be 0,0 and generate your render accordingly. But if for some reason you want that origin to be different, change it here.",
                    "type": "object",
                    "properties": {
                        "x": {
                            "type": "number",
                            "default": 0
                        },
                        "y": {
                            "type": "number",
                            "default": 0
                        }
                    },
                    "additionalProperties": false
                },
                "markers": {
                    "description": "Markers are placed before pieces, and thus can be obscured by them.",
                    "type": "array",
                    "items": {
                        "anyOf": [
                            {"$ref": "#/$defs/markerPath"},
                            {"$ref": "#/$defs/markerFreespaceLabel"},
                            {"$ref": "#/$defs/markerFreespaceGlyph"}
                        ]
                    }
                }
            },
            "required": ["width", "height"],
            "additionalProperties": false
        }
    },
    "type": "object",
    "properties": {
        "renderer": {
            "description": "The rendering engine the game wants to use.",
            "enum": [
                "default",
                "stacking-offset",
                "stacking-tiles",
                "stacking-expanding",
                "stacking-3D",
                "homeworlds",
                "homeworlds-orig",
                "entropy",
                "freespace",
                "sowing-numerals",
                "sowing-pips",
                "conhex",
                "multicell-square",
                "polyomino",
                "isometric"
            ],
            "default": "default"
        },
        "options": {
            "description": "A list of flags to pass to the renderer. The `hide-labels` option hides all external row/column labels. The `hide-labels-half` option only applies to boards with double labelling (e.g., square boards), and it hides the labels on the top and right of the board. `no-border` hides the very outside border of the square boards. The `hw-*` options are for Homeworlds. The option `clickable-edges` only applies to rect-of-hex and `squares*` boards and makes the individual edges clickable. The option `reverse-letters` reverses the order of the column or row displaying letters. The option `reverse-numbers` does the same for numerical labelling. The option `swap-labels` swaps the position of the letters and numbers. The option `no-piece-click` disables all click handling of pieces; instead only the board cells themselves detect the clicks.",
            "type": "array",
            "items": {
                "enum": ["hide-labels", "hide-labels-half", "hide-star-points", "no-border", "hw-light", "hw-no-buttons", "hw-system-only", "clickable-edges", "reverse-letters", "reverse-numbers", "swap-labels", "no-piece-click"]
            }
        },
        "legend": {
            "description": "Map each `piece` to an actual glyph with possible options.",
            "type": "object",
            "additionalProperties": {
                "anyOf": [
                    {
                        "description": "A simple string pointing to a specific glyph.",
                        "type": "string"
                    },
                    {
                        "$ref": "#/$defs/glyph"
                    },
                    {
                        "description": "The array version is for compositing glyphs into a single piece. Each glyph is simply stacked on top of the others.",
                        "type": "array",
                        "minItems": 1,
                        "items": {
                            "$ref": "#/$defs/glyph"
                        }
                    },
                    {
                        "$ref": "#/$defs/polymatrix"
                    },
                    {"$ref": "#/$defs/isoPiece"}
                ]
            }
        },
        "board": {
            "description": "This is the game board itself.",
            "oneOf": [
                {
                    "description": "Used to render a single glyph",
                    "type": "null"
                },
                {"$ref": "#/$defs/boardBasic"},
                {"$ref": "#/$defs/boardHomeworlds"},
                {"$ref": "#/$defs/boardEntropy"},
                {"$ref": "#/$defs/boardFreespace"}
            ]
        },
        "pieces": {
            "description": "Describes what pieces are where. For the `entropy` renderer, the pieces should be laid out on a grid 14 cells wide, which the renderer will break up into the two different boards. For cobweb boards, the center space is the final row, by itself. And for the `sowing` boards, the end pits (if present) should also appear on a row by themselves, west first (left), then east (right).",
            "anyOf": [
                {
                    "description": "If the board is completely empty.",
                    "type": "null"
                },
                {
                    "description": "One character per cell. Commas and whitespace are not permitted. Use a newline (\\n) to separate rows (the first row is the far row). Hyphens and underscores are reserved for representing blank spaces. Hyphens represent a single blank space. A line containing only an underscore will be interpreted as meaning the entire row is empty. (This only works for symmetrical boards. The row will be the width of the `board.width` property.)",
                    "type": "string",
                    "pattern": "^[^,\\r\\t\\f ]+$"
                },
                {
                    "description": "Comma-delimited string, allowing for multiple characters per cell. How multiple characters are handled depends on the renderer. The default renderer just assumes the character string matches a legend. Other renderers may assume the pieces are stacking (multiple single-character pieces stacked on top of each other). Use newlines to delimit rows (the first row is the far row). No other whitespace is permitted. Hyphens are *not* reserved here. Just put nothing between commas to indicate an empty cell. Underscores *are* still reserved, though. A line containing only an underscore will be interpreted as meaning the entire row is empty. (This only works for symmetrical boards. The row will be the width of the `board.width` property.)",
                    "type": "string",
                    "pattern": "^[^\\r\\t\\f ]+$"
                },
                {
                    "description": "Nested arrays. This level is the row (0 index being the top row).",
                    "type": "array",
                    "minItems": 1,
                    "items": {
                        "description": "Each item here represents a specific cell from left to right in the row (0 index being left most)",
                        "type": "array",
                        "minItems": 0,
                        "items": {
                            "description": "Each item here represents a specific cell from left to right in the row (0 index being left most). The default renderer layers the glyphs on top of each other in the order given. Other renderers may treat them as stacked in a more traditional sense (0 index being the bottom).",
                            "type": "array",
                            "minItems": 0,
                            "items": {
                                "description": "Use as many characters as you want. This is the only way to insert whitespace. How multiple characters are handled depends on the renderer. The default renderer just tries to match the string to the legend. Leaving an entire row empty will result in the renderer using the `board.width` property. Use an empty array to represent an empty cell.",
                                "type": "string"
                            }
                        }
                    }
                },
                {"$ref": "#/$defs/piecesHomeworlds"},
                {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/freepiece"
                    }
                },
                {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/multipiece"
                    }
                },
                {
                    "type": "array",
                    "items": {
                        "$ref": "#/$defs/polypiece"
                    }
                }
            ]
        },
        "areas": {
            "description": "Areas are renderer-specific elements that are used and rendered in various ways.",
            "type": "array",
            "items": {
                "anyOf": [
                    {"$ref": "#/$defs/areaPieces"},
                    {"$ref": "#/$defs/areaReserves"},
                    {"$ref": "#/$defs/areaPolyomino"},
                    {"$ref": "#/$defs/areaHWStash"},
                    {"$ref": "#/$defs/areaStackingExpanded"},
                    {"$ref": "#/$defs/areaVolcanoStash"},
                    {"$ref": "#/$defs/areaButtonBar"},
                    {"$ref": "#/$defs/areaScrollBar"},
                    {"$ref": "#/$defs/areaKey"}
                ]
            }
        },
        "annotations": {
            "description": "Instruct the renderer how to show any changes to the game state. See the docs for details. For the `entropy` renderer, the pieces are theoretically laid out on a grid 14 cells wide. So to show annotations on the second board, you will reference column indexes starting at 7. The number of rows does not change.",
            "type": "array",
            "items": {
                "anyOf": [
                    {"$ref": "#/$defs/annotationBasic"},
                    {"$ref": "#/$defs/annotationSowing"},
                    {"$ref": "#/$defs/annotationHomeworlds"},
                    {"$ref": "#/$defs/annotationFreespace"}
                ]
            }
        }
    },
    "required": ["board", "pieces"],
    "additionalProperties": false
}
