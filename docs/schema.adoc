= Render Schema Documentation
:toc:
:schemaver: 0.2.0

Games on the Abstract Play service must produce representations of the play area based on this schema. The front-end renderer will then translate that into various forms. The `description` fields in the schema itself are rather curt because JSON doesn't allow niceties like multi-line strings. So this file is intended to give you complete instructions on how to build an instance of this schema.

This document describes version {schemaver} of the schema.

== Concepts

The JSON file represents the game table.

At the very least, the table must contain a `board`, upon which one places `pieces`.

The table can also have multiple `areas`, which get placed vertically below the board in the order provided. These are used by specialized renderers for showing things like global stashes or previous game states.

== The Schema

This section walks through each of the properties of the schema and explains what they're for and how to use them. The `definitions` section is only there for convenience of notation and is not itself discussed.

=== `renderer`

This tells the renderer which engine to use. The following engines are available:

default:: This is the renderer used by most games. It does not support stacked pieces.
stacking-offset:: This works almost identically to the `default` engine but stacks multiple defined pieces on top of each other, slightly offset. Depending on the size of the board and pieces, excessive stack sizes will become problematic.
stacking-tiles:: This generates a side view of a stack of pieces defined only by their colour (player number). There is no legend of pieces, just the player colour. This is designed to be used with cells of fixed size and not vertex boards. It can show up to eight tiles, or, if there are nine or more tiles, seven will be visible with an "etc." tile on the bottom.
stacking-expanding:: This is a direct top-down view of stacked pieces. Larger pieces fully occlude smaller pieces beneath them. But the first `areas` definition can include a list of pieces, from bottom to top, that can be displayed vertically next to the board. This lets you fully inspect the contents of the stack, usually triggered by a click. This renderer requires `pieces` be specified using the nested-array approach described further below.
homeworlds:: This engine generates Homeworlds boards only.
entropy:: This is a game-specific renderer for laying out the side-by-side boards used in the game. This may be generalized at some point.

=== `legend`

Here you map references to glyphs and their options to (usually) single characters used to represent pieces in the `pieces` property. For player pieces, you need to use the object schema that includes the `player` property. For most other pieces, you'll just have a string that points to the glyph you want.

Glyphs are resolved based on user settings. The renderer will look at each glyph sheet in order until it finds the first implementation of that glyph. If it fails, an error will be thrown.

If you pass an array of glyphs, they are simply layered over each other, creating a composite piece. The object form supports the following options

player:: This marks the piece as belonging to a specific player. The fill colour will be chosen based on user settings. This is the preferred way to assign colours to pieces.
color:: A 3- or 6-digit hex colour value. This should only be used for tweaking composite pieces. Do not use this to assign player colours, which should be determined by player settings. Use the `player` property for that. This setting is ignored if `player` is also defined.
scale:: This is a factor for growing or shrinking a glyph. Values <1 cause the glyph to shrink. Values >1 cause it to grow.
opacity:: Applies an opacity to the entire glyph. A number between 0 and 1 where 0 is completely transparent.
rotate:: A number between -360 and 360 representing the number of degrees to rotate the glyph. A negative value rotates counterclockwise.
nudge:: A way of nudging a glyph off mathematical centre. Negative values nudge the piece up and to the left.

=== `board`

Now for the game board itself. This is rendered first, followed by the pieces.

* The first is a set of preset boards, which includes the following:
  squares:: A grid of squares, all of the same colour.
  squares-checkered:: Same as `squares` but alternating dark and light colours. The bottom-left cell is always dark.
  vertex:: Pieces are placed on the intersections of a grid of squares.
  vertex-cross:: Same as `vertex` but with crosses showing diagonal movement.
  go:: A special case of `vertex`. Always 19x19 with small nodes at the traditional points.
  hex-odd-p:: A pointy-topped hex grid where the odd-numbered rows are indented.
  hex-even-p:: A pointy-topped hex grid where the even-numbered rows are indented.
  hex-odd-f:: A flat-topped hex grid where the odd-numbered rows are indented.
  hex-even-f:: A flat-topped hex grid where the even-numbered rows are indented.
  hex-of-hex:: A hex-shaped board composed of hexagons.
  hex-of-tri:: A hex-shaped board composed of triangles.
  hex-of-cir:: A hex-shaped board composed of circles.
  snubsquare:: A basic https://en.wikipedia.org/wiki/Snub_square_tiling[snub square grid].

These boards are adjustable using the following properties:

strokeWeight:: Adjusts the width of the drawn lines.
strokeColour:: Adjusts the colour of the drawn lines.
strokeOpacity:: Adjusts the opacity of the drawn lines.
tileWidth:: Draws a thicker line every X columns. Used to simulate tiles on a standard board.
tileHeight:: Draws a thicker line every X rows. Used to simulate tiles on a standard board.

For the Homeworlds renderer, this is instead an array of objects that include the following properties:

name:: The characters A-Za-z0-9 and the hyphen and underscore (but not starting with a hyphen or underscore). Maximum length of 25.
stars:: An array of stars.
seat:: The value "N", "E", "S", or "W". Only defined if this is a home system

To render individual glyphs (e.g., for inclusion into running HTML), set `board` to `null`. Populate the `legend` as usual (but usually just for the one piece you need so as to minimize code size), and then just put the single piece in the `pieces` field. Render that with `renderStatic()` to get the raw code you can insert wherever you like. This will respect all colours, patterns, and glyph sheets as customized by the user.

=== `pieces`

Now that the board has been rendered, and there are spaces for the pieces, here's where you define where those pieces go. There are a few different ways of approaching this.

* First is a simple string. Each pieces must be represented by only a single character, mapped in the `legend`. Use `\n` to separate rows (the first row is the top row). Hyphens represent a single blank space. Underscores represent an entire empty row. Commas and whitespace are forbidden.

* This option is also a simple string but it uses commas to separate cells. This allows you to use multiple characters per cell. How multi-character cells are handled depends on the renderer. The default renderer just looks for a matching `legend` entry. But a stacking renderer will assume each character is a piece in a stack.
+
You still use `\n` to separate rows (the first row is the top row), and whitespace is still forbidden. Hyphens are _not_ reserved (just don't put anything after the comma to represent blank spaces), but underscores still represent blank rows.

* This nested-array approach is more explicit but also more verbose. Each top-level array is a row (the first row is the top row). Each row is itself an array of cells in that row (from left to right). And each cell is itself an array of pieces in that cell.
+
Different renderers will handle this differently. The default renderer will simply layer the glyphs on top of each other. A stacking renderer will try to stack the pieces.
+
The nested-array approach is the only acceptable way to layout pieces for the `stacking-expanding` renderer.

* Finally is the Homeworlds schema. This is also an array of arrays. Each top-level array is a system, and each of those contains an array of ships. The systems must be declared in the same order as in the `board` property. The renderer will deal with positioning the systems on the playing surface.

For the Homeworlds renderer, this is an array of arrays of ships. Ships must designate their owner. Ships are added to the systems by order of declaration.

=== `areas`

This section is unique to different renderers. The default renderer ignores it. 

The Homewords renderer uses this for the global stash. Provide the stash contents of each of the four colours.

The `stacking-expanding` renderer uses this to display an expanded column of pieces in a stack when requested.

=== `annotations`

This is how a game tells the renderer how to illustrate state changes. The following annotations are available:

- `move`: Draws a line to each cell.
- `enter`: Draws a dashed line around the new piece.
- `exit`: Draws a dashed line around the now-missing piece.
